; ═══════════════════════════════════════════════════════════════════════
; ПРОГРАММА УПРАВЛЕНИЯ ROM-DISK/32K ДЛЯ КОМПЬЮТЕРОВ "МИКРО-80" С МОНИТОРОМ
; СОВМЕСТИМЫМ С "РАДИО-86РК" И "РАДИО-86РК" С OБЪEMOM ОЗУ ПОЛЬЗОВАТЕЛЯ 16К/32К.
; ПРОГРАММА УПРАВЛЕНИЯ ЗАФИКСИРОВАНА В ПЗУ 
; ПО АДРЕСАМ 7E00H-7FFFH. УКАЗАННУЮ ОБЛАСТЬ ПЗУ 
; ЗАПРЕЩЕНО ИСПОЛЬЗОВАТЬ ПОД ROM-DISK. 
; ПРОГРАММА ИЗ ПЗУ В ОЗУ ПЕРЕНОСИТСЯ ЗАГРУЗЧИКОМ, 
; (В МОНИТОРЕ) ПО ДИРЕКТИВЕ "U" или "R". ЛУЧШЕ
; ЗАГРУЖАТЬ В ВЕРХНИЕ АДРЕСА ОЗУ, НАЧИНАЯ С 3400H/7400Н ДЛЯ РК-86.
; ДЛЯ "МИКРО-80" АДРЕС ОПРЕДЕЛЯЕТСЯ РАЗМЕРОМ ОЗУ: RAMTOP-200H
; ПРОГРАММА УПРАВЛЕНИЯ ПОЗИЦИОННО-НЕЗАВИСИМАЯ.
; ═══════════════════════════════════════════════════════════════════════

	CPU		8080
	Z80SYNTAX	EXCLUSIVE

; ───────────────────────────────────────────────────────────────────────
; Адреса системных вызовов
; ───────────────────────────────────────────────────────────────────────

	INCLUDE	"syscalls.inc"

	ORG	7400H		; По факту грузить можем в любые адреса

Stack:
Start:

; ───────────────────────────────────────────────────────────────────────
; Определяем адрес запуска программы
; выход: DE=BaseAddress
; ───────────────────────────────────────────────────────────────────────
	LD	HL, (0)
	EX	DE, HL			; DE=(0)
	LD	HL, 0E9E1H		; POP HL ! JP(HL)
	LD	(0), HL
	RST	0			; HL=BaseAddress
BaseAddress:
; ───────────────────────────────────────────────────────────────────────
; Устанавливаем по адресу RST 0 переход на обработчик относительного
; адреса
; ───────────────────────────────────────────────────────────────────────
	LD	A, 0C3H			; JMP ...
	LD	(0), A
	LD	A, (2)			; Сохраняем данные
	LD	BC, RST0-BaseAddress	; Смещение до обработчика
	ADD	HL, BC			; HL=RST0
	LD	(1), HL			; Адрес обработчика RST 0
	EX	DE, HL			; DE=RST0, HL=(0)
; ───────────────────────────────────────────────────────────────────────
; Сохраняем данные адресов 0-2 для последующего восстановления
; ───────────────────────────────────────────────────────────────────────
	RST	0
	LD	(RST0_0-$), HL
	RST	0
	LD	(RST0_2-$), A
; ───────────────────────────────────────────────────────────────────────
; Настраиваем стек
; ───────────────────────────────────────────────────────────────────────
	RST	0
	LD	SP, Stack-$
; ───────────────────────────────────────────────────────────────────────
; Проверяем наличие Микро-80 (Монитор РК)
; ───────────────────────────────────────────────────────────────────────
	LD	A, (0FFD8H)		; Проверяем наличие Микро-80 с М/80К
	CP	038H			; Букава 'm' от приветствия
	RST	0
	JP	NZ, RK86-$		; Если есть, то запускаем её
; ───────────────────────────────────────────────────────────────────────
; Патчим адрес директивы чтения из ПЗУ МИКРО-80
; ───────────────────────────────────────────────────────────────────────
	RST	0
	LD	HL, (Patch1+1)-$
	LD	DE, 0F9E6H		; Адрес копирования ROM-диска в Микро-80
	LD	(HL), E
	INC	HL
	LD	(HL), D
	RST	0
	LD	HL, (Patch2+1)-$
	LD	(HL), E
	INC	HL
	LD	(HL), D
;	RST	0
;	JP	M80-$			; Пропускаем проверку РК-ДОС
; ───────────────────────────────────────────────────────────────────────
; Проверяем наличие РК-ДОС
; (байт по 0E000H содержит AFH)
; @todo запуск РК-ДОС
; ───────────────────────────────────────────────────────────────────────
RK86:
;	LD	A, (0E000H)		; Проверяем наличие РК-ДОС
;	CP	0AFH
;	JP	Z, 0E000H		; Если есть, то запускаем её
; ───────────────────────────────────────────────────────────────────────
; Выводим приветствие
; ───────────────────────────────────────────────────────────────────────
M80:
	RST	0
	LD	HL, SO1-$
	PUSH	HL
	CALL	PrintString
	POP	HL
	LD	(HL), 0CH		; Заменяем CrlScr на Home
; ───────────────────────────────────────────────────────────────────────
; Выводим каталог диска
; ───────────────────────────────────────────────────────────────────────
	LD	B, 0			; Первый элемент выбран

InputLoop:
	RST	0
	CALL	SEARCHS-$
	RST	0
	LD	HL, MaxItems-$
	DEC	C
	LD	(HL), C
	RST	0
	LD	HL, SO3-$		; Печатаем перевод строки
	CALL	PrintString
; ───────────────────────────────────────────────────────────────────────
; Обрабатываем меню
; ───────────────────────────────────────────────────────────────────────
	CALL	InputSymbol
	CP	0DH
	RST	0
	JP	Z, ExitLoop-$

	CP	1BH
	JP	Z, WarmBoot

	CP	1AH
	RST	0
	JP	NZ, Next1-$
	LD	A, B
	RST	0
	LD	HL, MaxItems-$
	CP	(HL)
	RST	0
	JP	Z, Next2-$
	INC	B
	RST	0
	JP	Next2-$
Next1:
	CP	19H
	RST	0
	JP	NZ, Next2-$
	LD	A, B
	CP	0
	RST	0
	JP	Z, Next2-$
	DEC	B
Next2:
	RST	0
	LD	HL, SO1-$
	CALL	PrintString
	RST	0
	JP	InputLoop-$
ExitLoop:
; ───────────────────────────────────────────────────────────────────────
; Изменяем функцию вызова печати, на функцию запуска программы
; ───────────────────────────────────────────────────────────────────────
	RST	0
	LD	HL, (Patch3+1)-$
	RST	0
	LD	DE, EXECN-$
	LD	(HL), E
	INC	HL
	LD	(HL), D
; ───────────────────────────────────────────────────────────────────────
; Запускаем выбранную программу
; ───────────────────────────────────────────────────────────────────────
					; Просто проваливаемся дальше
; ───────────────────────────────────────────────────────────────────────
; Подпрограмма перебора каталога диска
; ───────────────────────────────────────────────────────────────────────
SEARCHS:
	LD	HL, 0800H		; Начало ROM-диска
	LD	C, L			; LD C, 0
SEARCH:
	PUSH	HL			; (1)
	LD	DE, (8+2+2)-1
	ADD	HL, DE
	EX	HL, DE
	POP	HL			; (1)

	PUSH	HL			; (2)

	PUSH	BC			; (3)

	RST	0
	LD	BC, T-$
	PUSH	BC			; (4)
Patch1:
	CALL	ReadROM
	POP	HL			; (4)

	POP	BC			; (3)

	LD	A, (HL)
	CP	0FFH

	POP	DE			; (2)

	RET	Z

	RST	0
Patch3:	CALL	PRINTN-$

	PUSH	DE			; (5)
;---------------------
	RST	0
	LD	HL, (((T+8+2)-$) & 0ffffh)
	LD	A, L			; высчитываем начало следующей записи
	OR	A			; оканчивается на ноль
	RST	0
	JP	Z, SKIP-$
	OR	0FH
	LD	L, A
	INC	HL
SKIP:
	LD	DE, 10H
	ADD	HL, DE
;---------------------
	POP	DE			; (5)

	ADD	HL, DE
	INC	C

	RST	0
	JP	SEARCH-$
; ───────────────────────────────────────────────────────────────────────
; Подпрограмма печати записи каталога
; ───────────────────────────────────────────────────────────────────────
PRINTN:
	PUSH	HL
	PUSH	BC

	LD	A, C

	LD	C, 06H
	CALL	PrintCharFromC

	SUB	B
	LD	C, ' '
	RST	0
	JP	NZ, NotActive1-$
	LD	C, 0EH
NotActive1:
	CALL	PrintCharFromC

	LD	B, 8
	RST	0
	LD	HL, T-$
PLOOP:	LD	C, (HL)			; Печатаем имя
	CALL	PrintCharFromC
	INC	HL
	DEC	B
	RST	0
	JP	NZ, PLOOP-$

	INC	HL
	
	POP	BC
	PUSH	BC
	
	LD	A, C
	SUB	B
	LD	C, ' '
	RST	0
	JP	NZ, NotActive2-$
	LD	C, 1DH
NotActive2:
	CALL	PrintCharFromC
	RST	0			; Печатаем стартовый адрес
	CALL	PrintHexWord-$

	INC	HL
	INC	HL
	INC	HL
	LD	C, ' '			; Печатаем размер
	CALL	PrintCharFromC
	RST	0
	CALL	PrintHexWord-$

	LD	C, 11h
	CALL	PrintCharFromC
	RST	0
	LD	HL, SO2-$		; Печатаем перевод строки
	CALL	PrintString

	POP	BC
	POP	HL
	RET

PrintHexWord:
	LD	A, (HL)
	CALL	PrintHexByte
	DEC	HL
	LD	A, (HL)
	JP	PrintHexByte

; ───────────────────────────────────────────────────────────────────────
; Подпрограмма запуска программы
; ───────────────────────────────────────────────────────────────────────
EXECN:
	LD	A, C
	SUB	B
	RET	NZ
	
	LD	HL, 010H
	ADD	HL, DE		; DE - это адрес на ROM-диске
	EX	DE, HL

; Восстанавливаем память 0-2
	RST	0
	LD	HL, ((RST0_0-$) & 0ffffh)
	RST	0
	LD	A, ((RST0_2-$) & 0ffffh)

	RST	0
	LD	SP, (T+8)-$	; Используя стек, ниже читаемчитаем...

	LD	(0), HL
	LD	(2), A


	POP	BC		; Начальный адрес
	POP	HL		; Размер

	ADD	HL, DE
	EX	DE, HL

	PUSH	BC		; Адрес запуска
Patch2:
	JP	ReadROM		; Читаем в ОЗУ и запускаем программу

RST0_0:	DW	0
RST0_2:	DB	0
T:	DB	8+2+2 DUP 0
SO1:	DB 	1FH,0AH,0DH,"*ROM-DISK/32K* V3.0-24"
	DB 	0AH,0DH," \x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14"
SO2:	DB	0AH,0DH, 0
SO3:	DB 	" \x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3",0dh,0ah
	DB	"ar2-wyhod, ",0bh,0fh,"-wybor, wk-zapusk ",0
MaxItems:
	DB	0


; ───────────────────────────────────────────────────────────────────────
; Подпрограмма модификации относительного адреса перехода
; ───────────────────────────────────────────────────────────────────────
RST0:	EX	(SP),HL		; Save H,L and get next PC
	PUSH	DE		; Save D,E.
	PUSH	AF		; Save condition codes.
	DEC	HL		; Change RST 0 to NOP.
	LD	(HL),00H
	INC	HL

	INC	HL
	LD	E,(HL)		; Get relative addr. in D, E.
	INC	HL
	LD	D,(HL)
	EX	DE,HL		; Add offset for abs. addr.
	ADD	HL,DE
	EX	DE,HL
	DEC	DE		; Set to beginning of instr
	DEC	DE
	LD	(HL),D		; Store absolute addr.
	DEC	HL
	LD	(HL),E
	POP	AF		; Restore condition codes.
	POP	DE		; Restore D,E.
	DEC	HL		; Set H,L to start of instr
	EX	(SP),HL		; Restore H,L
	RET

	DB	7600H-$ DUP (0FFH)
