; ═══════════════════════════════════════════════════════════════════════
; ПРОГРАММА УПРАВЛЕНИЯ ROM-DISK/32K ДЛЯ КОМПЬЮТЕРОВ "МИКРО-80" С МОНИТОРОМ
; СОВМЕСТИМЫМ С "РАДИО-86РК" И "РАДИО-86РК" С OБЪEMOM ОЗУ ПОЛЬЗОВАТЕЛЯ 16К/32К.
; ПРОГРАММА УПРАВЛЕНИЯ ЗАФИКСИРОВАНА В ПЗУ 
; ПО АДРЕСАМ 7E00H-7FFFH. УКАЗАННУЮ ОБЛАСТЬ ПЗУ 
; ЗАПРЕЩЕНО ИСПОЛЬЗОВАТЬ ПОД ROM-DISK. 
; ПРОГРАММА ИЗ ПЗУ В ОЗУ ПЕРЕНОСИТСЯ ЗАГРУЗЧИКОМ, 
; (В МОНИТОРЕ) ПО ДИРЕКТИВЕ "U" или "R". ЛУЧШЕ
; ЗАГРУЖАТЬ В ВЕРХНИЕ АДРЕСА ОЗУ, НАЧИНАЯ С 3400H/7400Н ДЛЯ РК-86.
; ДЛЯ "МИКРО-80" АДРЕС ОПРЕДЕЛЯЕТСЯ РАЗМЕРОМ ОЗУ: RAMTOP-200H
; ПРОГРАММА УПРАВЛЕНИЯ ПОЗИЦИОННО-НЕЗАВИСИМАЯ.
; ═══════════════════════════════════════════════════════════════════════

	CPU		8080
	Z80SYNTAX	EXCLUSIVE

; ───────────────────────────────────────────────────────────────────────
; Адреса системных вызовов
; ───────────────────────────────────────────────────────────────────────

	INCLUDE	"syscalls.inc"

	ORG	BASE-0200H

Stack:
Start:

; ───────────────────────────────────────────────────────────────────────
; Определяем адрес запуска программы
; выход: DE=BaseAddress
; ───────────────────────────────────────────────────────────────────────
	LD	HL, (0)
	EX	DE, HL			; DE=(0)
	LD	HL, 0E9E1H		; POP HL ! JP(HL)
	LD	(0), HL
	RST	0
BaseAddress:
	EX	DE, HL			; DE=BaseAddress, HL=(0)
	LD	(0), HL

; ───────────────────────────────────────────────────────────────────────
; Устанавливаем по адресу RST 0 переход на обработчик относительного
; адреса
; ───────────────────────────────────────────────────────────────────────
	LD	HL, (0)			; Сохраняем данные
	LD	B, H
	LD	C, L
	LD	A, 0C3H			; JMP ...
	LD	(0), A
	LD	A, (2)			; Сохраняем данные
	LD	HL, RST0-BaseAddress	; Смещение до обработчика
	ADD	HL, DE
	LD	(1), HL			; Адрес обработчика RST 0
	LD	H, B			; Запоминаем данные для
	LD	L, C			; последующего восстановления
	RST	0
	LD	(RST0_0-$), HL
	RST	0
	LD	(RST0_2-$), A

; ───────────────────────────────────────────────────────────────────────
; Настраиваем стек
; ───────────────────────────────────────────────────────────────────────
	RST	0
	LD	SP, Stack-$

; ───────────────────────────────────────────────────────────────────────
; Проверяем наличие Микро-80 (Монитор РК)
; ───────────────────────────────────────────────────────────────────────

	LD	A, (0FFD8H)		; Проверяем наличие Микро-80 с М/80К
	CP	038H
	RST	0
	JP	NZ, RK86-$		; Если есть, то запускаем её

; ───────────────────────────────────────────────────────────────────────
; Патчим адрес директивы чтения из ПЗУ
; ───────────────────────────────────────────────────────────────────────
	RST	0
	LD	HL, (Patch1+1)-$
	LD	DE, 0F9E6H
	LD	(HL), E
	INC	HL
	LD	(HL), D
	RST	0
	LD	HL, (Patch2+1)-$
	LD	(HL), E
	INC	HL
	LD	(HL), D
	RST	0
	JP	M80-$			; Пропускаем проверку РК-ДОС

; ───────────────────────────────────────────────────────────────────────
; Проверяем наличие РК-ДОС
; (байт по 0E000H содержит AFH)
; ───────────────────────────────────────────────────────────────────────
RK86:
	LD	A, (0E000H)		; Проверяем наличие РК-ДОС
	CP	0AFH
	JP	Z, 0E000H		; Если есть, то запускаем её

; ───────────────────────────────────────────────────────────────────────
; Выводим приветствие
; ───────────────────────────────────────────────────────────────────────
M80:
	RST	0
	CALL	RST_18-$
SO1:	DB 	0AH,0DH,"*ROM-DISK/32K* V3.0-24"
	DB 	0AH,0AH,0DH,"DIRECTORY:"
SO2:	DB	0AH,0DH, 0

; ───────────────────────────────────────────────────────────────────────
; Выводим каталог диска
; ───────────────────────────────────────────────────────────────────────
	LD	B, 0FFH
	RST	0
	CALL	SEARCHS-$

; ───────────────────────────────────────────────────────────────────────
; Выводим приглашение и ждем номер программы
; ───────────────────────────────────────────────────────────────────────
	LD	C, '>'
	CALL	PrintCharFromC
	CALL	InputSymbol
	LD	C, A
	CALL	PrintCharFromC
	CP	03h
	JP	Z,WarmBoot
	SUB	30H

	LD	B, A

; ───────────────────────────────────────────────────────────────────────
; Изменяем функцию вызова печати, на функцию запуска программы
; ───────────────────────────────────────────────────────────────────────
	RST	0
	LD	HL, (FUNC+1)-$
	RST	0
	LD	DE, EXECN-$
	LD	(HL), E
	INC	HL
	LD	(HL), D
	
; ───────────────────────────────────────────────────────────────────────
; Запускаем выбранную программу
; ───────────────────────────────────────────────────────────────────────
	RST	0
	CALL	SEARCHS-$
	RST	0
	CALL	RESTORERST-$
	JP	WarmBoot

; ───────────────────────────────────────────────────────────────────────
; Подпрограмма модификации относительного адреса перехода
; ───────────────────────────────────────────────────────────────────────

RST0:	ex	(sp),hl		; Save H,L and get next PC
	push	de		; Save D,E.
	push	af		; Save condition codes.
	dec	hl		; Change RST 0 to NOP.
	ld	(hl),00h
	inc	hl

	inc	hl
	ld	e,(hl)		; Get relative addr. in D, E.
	inc	hl
	ld	d,(hl)
	ex	de,hl		; Add offset for abs. addr.
	add	hl,de
	ex	de,hl
	dec	de		; Set to beginning of instr
	dec	de
	ld	(hl),d		; Store absolute addr.
	dec	hl
	ld	(hl),e
	pop	af		; Restore condition codes.
	pop	de		; Restore D,E.
	dec	hl		; Set H,L to start of instr
	ex	(sp),hl		; Restore H,L
	ret

; ───────────────────────────────────────────────────────────────────────
; Подпрограмма перебора каталога диска
; ───────────────────────────────────────────────────────────────────────

SEARCHS:
	LD	HL, 0800H		; Начало ROM-диска
	LD	C, L			; LD C, 0
SEARCH:
	PUSH	HL			; (1)
	LD	DE, (8+2+2)-1
	ADD	HL, DE
	EX	HL, DE
	POP	HL			; (1)

	PUSH	HL			; (2)

	PUSH	BC			; (3)

	RST	0
	LD	BC, T-$
	PUSH	BC			; (4)
Patch1:
	CALL	ReadROM
	POP	HL			; (4)

	POP	BC			; (3)

	LD	A, (HL)
	CP	0FFH

	POP	DE			; (2)

	RET	Z

	RST	0
FUNC:	CALL	PRINTN-$

	PUSH	DE			; (5)
;---------------------
	RST	0
	LD	HL, (((T+8+2)-$) & 0ffffh)
	LD	A, L			; высчитываем начало следующей записи
	OR	A			; оканчивается на ноль
	RST	0
	JP	Z, SKIP-$
	OR	0FH
	LD	L, A
	INC	HL
SKIP:
	LD	DE, 10H
	ADD	HL, DE
;---------------------
	POP	DE			; (5)

	ADD	HL, DE
	INC	C

	RST	0
	JP	SEARCH-$

; ───────────────────────────────────────────────────────────────────────
; Подпрограмма печати записи каталога
; ───────────────────────────────────────────────────────────────────────
PRINTN:
	PUSH	HL
	PUSH	BC

	LD	A, C			; Печатаем порядковый номер
	ADD	A, 30H
	LD	C, A
	CALL	PrintCharFromC
	LD	C, ' '
	CALL	PrintCharFromC

	LD	B, 8
	RST	0
	LD	HL, T-$
PLOOP:	LD	A, (HL)			; Печатаем имя
	CP	"$"
	RST	0
	CALL	Z, PrintCOM-$
	LD	C, A
	CALL	PrintCharFromC
	INC	HL
	DEC	B
	RST	0
	JP	NZ, PLOOP-$

	INC	HL
	LD	C, ' '			; Печатаем стартовый адрес
	CALL	PrintCharFromC
	LD	A, (HL)
	CALL	PrintHexByte
	DEC	HL
	LD	A, (HL)
	CALL	PrintHexByte

	INC	HL
	INC	HL
	INC	HL
	LD	C, ' '			; Печатаем размер
	CALL	PrintCharFromC
	LD	A, (HL)
	CALL	PrintHexByte
	DEC	HL
	LD	A, (HL)
	CALL	PrintHexByte

	RST	0
	LD	HL, SO2-$		; Печатаем перевод строки
	CALL	PrintString
	POP	BC
	POP	HL
	RET

; ───────────────────────────────────────────────────────────────────────
; Подпрограмма запуска программы
; ───────────────────────────────────────────────────────────────────────
EXECN:
	LD	A, C
	SUB	B
	RET	NZ
	
	LD	HL, 010H
	ADD	HL, DE		; DE - это адрес на ROM-диске
	EX	DE, HL

	RST	0
	LD	SP, (T+8)-$	; Используя стек, читаем...
	RST	0		
	CALL	RESTORERST-$	; Восстанавливаем память
	POP	BC		; Начальный адрес
	POP	HL		; Размер

	ADD	HL, DE
	EX	DE, HL

	PUSH	BC		; Адрес запуска
Patch2:
	CALL	ReadROM		; Читаем в ОЗУ
	RET			; Запускаем программу

; ───────────────────────────────────────────────────────────────────────
; Подпрограмма восстановления вектора RST 0
; ───────────────────────────────────────────────────────────────────────
RESTORERST:
	RST	0
	LD	HL, ((RST0_0-$) & 0ffffh)
	RST	0
	LD	A, ((RST0_2-$) & 0ffffh)
	LD	(0), HL
	LD	(2), A
	RET

RST_18:	EX	(SP),HL		; 6 bytes
	CALL	PrintString
	EX	(SP),HL
	RET

RST0_0:	DW	0
RST0_2:	DB	0
T:	DB	8+2+2 DUP 0

PrintCOM:
	PUSH	HL
	RST	0
	CALL	RST_18-$
SO0:	DB	".COM", ' ', 0
	POP	HL
	RET

	DB	BASE-$ DUP (0FFH)
