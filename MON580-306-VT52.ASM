;  ══════════════════════════════════════════════════════════════════
;  МОНИТОР РК86 для КР580 совместимый с Z80, VT-52 и симулятором CP/M
;  ══════════════════════════════════════════════════════════════════
;
; Last modify: 09.05.2021
;
;
; IDEAS
; -----
;
; 1. Проверить, упакуются ли все Esc-коды, возможно и Ctrl-коды в
;    диапазон Fx00-FxFF. Тогда заюзать однобайтовы массив для переходов
; 2. То же для директив
; Это два пункта сохранять байты на анализ
;
; Звук только на INTE
; В CCP принудительно включается ЛАТ-регистр.
; Удалена директива X. Директива G теперь не имеет второго параметра -
; стоп точки. Зато теперь введён возврат из запуска по G по RET. И можно
; передавать два параметра (второй и третий, они передаются в DE и BC).
; При запуске директивой G100 включается режим симулятора CP/M.
; При этом формируется нулевая страница. BDOS размещается в адресах
; RAMTOP-100H и занимает 3 байта. BIOS размещается в адресах 
; RAMTOP-100H и занимает 15 байт. Нулевая точка входа в BIOS 
; используется для эмуляции BDOS, т.к. она в никогда не вызывается
; из прикладных программ (как минимум, мне об этом неизвестно)
;
;
; ВВОД ДИРЕКТИВ И АНАЛИЗ РЕЗУЛЬТАТОВ
; ──────────────────────────────────
;
; После запуска МОНИТОРа экран телевизора очищается, в левом верхнем углу
; появляется надпись <РАДИО-86РК>, а под ней - стрелка -->, уведомляющая
; пользователя о том, что МОНИТОР готов к вводу очередной директивы.
; Неверно набранные символы стирают нажатием на клавишу <ЗБ> (<Забой>).
; <<-> (<Курсор влево>), в отличие от оригинального МОНИТОРа, просто
; смкщает курсор влево. Для выполнения директивы нажимают на клавишу
; возврата каретки "ВК". Если директива задана правильно, то начнется ее
; выполнение, если нет, - на экране появится знак вопроса - признак того,
; что МОНИТОР "не понимает" вашу директиву или произошло переполнение буфера
; ввода.
; 
; Выполнение директив О, L, S может быть прервано. Для этого, удерживая
; клавишу <УС>, надо нажать еще и на <С>; выполнение директивы прервется,
; и МОНИТОР будет готов выполнять следующую.
; 
; Имена всех директив состоят из одной латинской буквы, непосредственно за
; которой могут следовать не более трех параметров, представляющих собой
; шестнадцатеричные числа. Один параметр от другого отделяют запятой или
; пробелом. Их ставят и в тех случаях, когда один из параметров (в том
; числе и первый) отсутствует.
; 
; ДИРЕКТИВЫ РАБОТЫ С ПАМЯТЬЮ
; ──────────────────────────
;
; Содержимое области памяти может быть выведено на экран дисплея либо в
; виде шестнадцатеричных чисел (директива О), либо в виде алфавитно-
; цифровых символов, соответствующих этим кодам (директива L). Если
; при выполнении последней встретятся коды, не соответствующие ни одному
; алфавитно-цифровому символу, то они отобразятся в виде точек. Содержимое
; памяти выводится в виде таблицы из 16 колонок. Слева от каждой строки
; указывается шестнадцатеричный адрес первой в строке ячейки. Форматы
; этих и других директив приведены в табл. 5. Директива М предназначена
; для просмотра и изменения содержимого одной или нескольких ячеек памяти.
; После ее ввода на экране высвечивается адрес ячейки и ее содержимое,
; курсор останавливается справа от этого значения, и МОНИТОР "ожидает"
; ввода с клавиатуры. Если необходимо изменить содержимое ячейки, набирают
; новое значение и нажимают клавишу "ВК", если изменений не требуется, ее
; нажимают сразу же. При каждом нажатии на клавишу "ВК" значение адреса
; автоматически увеличивается на единицу. Выполнение директивы продолжается
; до тех пор, пока не будет нажата клавиша "." (точка).
; 
; Таблица 5
; 
; ДИРЕКТИВЫ МОНИТОРА
; ДИРЕКТИВЫ РАБОТЫ С ПАМЯТЬЮ
; D <НАЧАЛЬНЫЙ АДРЕС>,<КОНЕЧНЫЙ АДРЕC>
; L < НАЧАЛЬНЫЙ АДРЕС>,<КОНЕЧНЫЙ АДРЕС>
; F <НАЧАЛЬНЫЙ АДРЕС >, <КОНЕЧНЫЙ АДРЕС>, <ЗАПИСЫВАЕМЫЙ КОД>
; M <АДРЕС>
; T <НАЧАЛЬНЫЙ АДРЕС>, <КОНЕЧНЫЙ АДРЕС>, <АДРЕС ОБЛАСТИ ПЕРЕСЫЛКИ>
; C <НАЧАЛЬНЫЙ АДРЕС>, <КОНЕЧНЫЙ АДРЕС>, <АДРЕС ОБЛАСТИ СРАВНЕНИЯ>
; S <НАЧАЛЬНЫЙ АДРЕC>, <КОНЕЧНЫЙ АДРЕС>, <ИСКОМЫЙ КОД>
; ДИРЕКТИВЫ ЗАПУСКА И ОТЛАДКИ
; G <АДРЕС ЗАПУСКА>
; ДИРЕКТИВЫ ВВОДА-ВЫВОДА
; O <НАЧАЛЬНЫЙ АДРЕС >,< КОНЕЧНЫЙ АДРЕС>,/<СКОРОСТЬ>/
; I <СМЕЩЕНИЕ >/,/< СКОРОСТЬ>/
; ДОПОЛНИТЕЛЬНЫЕ ДИРЕКТИВЫ
; R <НАЧАЛЬНЫИ АДРЕС ПЗУ>, <КОНЕЧНЫИ АДРЕС ПЗУ>, <АДРЕС ЗАГРУЗКИ>
; U
; (НАКЛОННЫМИ ЧЕРТАМИ ВЫДЕЛЕНЫ НЕОБЯЗАТЕЛЬНЫЕ ПАРАМЕТРЫ)
; Если во все ячейки области памяти необходимо записать одинаковые коды,
; удобно воспользоваться директивой Р.
; 
; Директива Т предназначена для копирования (пересылки) содержимого одной
; области памяти в другую. Копирование осуществляется побайтно, начиная с
; младшего адреса.
; 
; Для сравнения двух областей памяти необходимо пользоваться директивой С.
; Если содержимое соответствующих ячеек памяти не совпадает, на экран
; выводится адрес ячейки из первой области, ее содержимое и содержимое
; соответствующей ячейки из второй области. МОНИТОР предоставляет
; пользователю возможность поиска кода в заданной области памяти
; (директива S). При обнаружении искомого кода на экране появляются
; адреса ячеек, в которых он был обнаружен.
; 
; ДИРЕКТИВЫ ЗАПУСКА И ОТЛАДКИ ПРОГРАММ
; ────────────────────────────────────
;
; Для запуска программы служит директива G. Второй параметр этой
; директивы, задающий адрес останова, используется только при отладке
; программ и может быть опущен. Кроме того, пользователь может сам
; назначать в своей программе контрольные адреса останова, записав
; по этим адресам код команды RST6 (0F7Н). Если при выполнении программы
; встретится эта команда, управление будет передано МОНИТОРу, который
; сообщит адрес, в котором было прервано выполнение программы, после
; чего пользователь может воспользоваться любыми директивами МОНИТОРА
; для контроля результатов работы и модификации программы.
; 
; Просмотреть и изменить содержимое внутренних регистров микропроцессора
; поможет директива Х (не имеющая параметров). В результате ее выполнения
; на экран выводятся символические имена и содержимое регистров, которое
; можно изменять так же, как и содержимое ячеек памяти по директиве М.
; Регистр признаков результата операции обозначен латинской буквой Р,
; обозначение других внутренних регистров микропроцессоре стандартно.
; 
; ДИРЕКТИВЫ ВВОДА-ВЫВОДА
; ──────────────────────
;
; Первые два параметра директивы вывода на магнитную ленту О задают
; область памяти, содержимое которой подлежит выводу, третий -
; шестнадцатеричный код, определяющий скорость вывода. Если скорость
; не указать, то будет использовано либо значение, заданное в предыдущей
; директиве вывода, либо стандартное - 1DH (около 1200 бит/с), записываемое
; (при нажатии на кнопку <СБРОС>) в рабочую ячейку МОНИТОРа 03630Н
; (использовать константу вывода менее 10Н недопустимо!). Рекомендуем
; пользоваться стандартной скоростью, так как она выбрана с учетом
; использования магнитофона и магнитной ленты невысокого качества.
; Кроме того, стандартная скорость облегчит обмен программами. После
; завершения вывода, на экране отобразятся начальный и конечный адреса
; и четырехзначная контрольная сумма выведенной информации.
; 
; Ввод с ленты осуществляется по директиве I, которая может иметь два
; параметра. Первым параметром - необязательным - задают смещение. Если
; он есть, вводимая информация будет загружена по адресу, являющемуся
; суммой указанного в записи на ленте адреса и смещения. Второй параметр
; определяет временную задержку при чтении с ленты. Он также может
; отсутствовать, но в этом случае будет взята задержка, использовавшаяся
; в предыдущей команде ввода (если вы не нажимали на кнопку <СБРОС>) или
; установленная (по умолчанию) при начальной настройке рабочих ячеек
; МОНИТОРа (стандартное значение, записанной по адресу 0362FH - 2АН).
; 
; После окончания ввода МОНИТОР сообщит начальный и конечный адреса
; загрузки и контрольную сумму, подсчитанную при вводе информации.
; Если она не совпадет с введенной с ленты, то на следующей строке
; будет выведено значение, записанное на ленте. Этот факт
; свидетельствует об ошибках при чтении информации с ленты.
; 
; Прервать программу ввода с магнитной ленты можно либо выключением
; магнитофона, либо вводом с клавиатуры кода <УС> + <С> (здесь и
; далее латинский регистр).
; 
; Используемый в РК формат записи на магнитную ленту отличается от
; используемого в <Микро-80> только наличием в конце выводимой
; информации контрольной суммы, поэтому программы, записанные с
; <Радио-86РК>, могут быть введены в <Микро-80>. При попытке
; ввести в РК программу, записанную с <Микро-80>, подпрограмма
; ввода будет ожидать ввода контрольной суммы. Если не останавливать
; магнитофон и <позволить> ей читать начало следующей программы, то
; она будет воспринята как контрольная сумма и ввод будет окончен.
; Естественно, что такая <контрольная сумма> не совпадет с реальной,
; и МОНИТОР <ответит> на эти действия вопросительным знаком,
; 
; В табл. 5 приведены форматы еще двух директив: R - чтения
; информации из ПЗУ, подключаемого к ППА D14, и U - предназначенной
; для дальнейшего расширения МОНИТОРа. О них будет рассказано в одном
; из следующих номеров журнала.
; 
; 
; УПРАВЛЯЮЩИЕ КОДЫ ДИСПЛЕЯ
; ────────────────────────
;
; Данная версия МОНИТОРа реализует поддержку управляющих кодов
; дисплея, своместимых с терминалом DECscope VT52. В связи с
; этим, поведение некоторых управляющих кодов отличается от
; оригинальной версии МОНИТОРа.
;
; Управляющие коды, в отличие от остальных, не отображаются в виде
; алфавитно-цифрового или псевдографического символа, а вызывают
; выполнение какой-либо специфичной функции, связанной с управлением
; форматом выводимых на экран сообщений (табл.8).
; 
; Функция <- (<Курсор влево>) вызывает перемещение курсора на одну
; позицию влево. Если курсор находился в самой левой позиции строки,
; то его перемещение, в отличие от оригинального МОНИТОРа, не происходит.
; 
; Функция -> (<Курсор вправо>) перемещает курсор в противоположном
; направлении. Переход курсора на другую стоку, в отличие от оригинального
; МОНИТОРа, не происходит.
; 
; Функции - (<Курсор вверх>) и (<Курсор вниз>) вызывают перемещение
; курсора на одну строку вверх или вниз соответственно. Если при этом
; курсор находился в самой нижней строке экрана, то при выполнении
; функции <Курсор вниз> он, в отличие от оригинального МОНИТОРа,
; останется на той же строе. Аналогично и с функцией <Курсор вверх>.
; 
; Функция <ВК> - <Возврат каретки> (не путать с клавишей) переведет курсор
; в первую позицию той же строки экрана, в которой он и находился. Если
; курсор уже находится в самой левой позиции, его положение не изменится.
; 
; Функция <ПС> (<Перевод строки>) действует так же, как и <Курсор вниз>,
; в том случае, если курсор не находится в последней строке экрана, в
; противном случае курсор остается в прежней позиции, и на экране происходят
; следующие изменения: на месте первой строки появляется вторая, на месте
; второй - третья и т. д., последняя строка экрана очищается. Таким образом,
; текст на экране дисплея передвигается на одну строку вверх, вся информация,
; высвечиваемая в первой строке, теряется, а последняя строка освобождается
; для вывода новой строки символов. Данный процесс называется прокруткой
; экрана.
; 
; Функция <СТР> (<Стирание экрана>) полностью стирает весь текст на экране
; и устанавливает курсор в нулевую позицию (левый верхний угол).
; 
; Функция <\> (<Курсор в начало экрана>) перемещает курсор в левый верхний
; угол экрана. Информация на экране остается неизменной.
; 
; Функция "BEL" выдаст звуковой сигнал продолжительностью примерно 0,25 с.
;
; Функция "TAB" размещает курсор в ближайшей следующей позиции "табулятора".
; Т.е. в позициях 8, 16, 24,32,40,48, 56. Отсчет ведется от 0.
;
; Функция "ESC" переводит в режим обработки Escape-кодов.
;
; Код "A" - Курсор вверх
;
; Код "B" - Курсор вниз
;
; Код "C" - Курсор вправо
;
; Код "D" - Курсор влево
;
; Код "E" - очистка экрана (расширение GDOS/TOS)
;
; Код "F" -- не используется, зарезервирована для включения алтернативного знакогенератора
;
; Код "G" -- не используется, зарезервирована для выключения алтернативного знакогенератора
;
; Код "H" - перемещение курсора в левый верхний угол
;
; Код "I" - обратный перевод строки. Поведение аналогино переводу строки, но прокрутка вверх
;
; Код "J" - очистка до конца экрана
;
; Код "K" - очистка до конца строки
;
; Код "L" - не используется, Insert a line (нет в описании VT-52)
;
; Код "M" - не используется, Remove line (нет в описании VT-52)
;
; Код "Y" - функция прямой адресации курсора. Чтобы установить курсор
; в требуемую позицию на экране, необходимо выдать на дисплей
; последовательность кодов: 1ВН+59Н+(НОМЕР СТРОКИ+20Н)+(НОМЕР ПОЗИЦИИ + 20H).
; Строки и позиции на экране отсчитываются от 0, причем нулевой строкой
; экрана считается самая верхняя строка, а нулевой позицией - самая левая.
;
; Код "Z" - не используется, идентификация типа терминала
;
; Код "[" - не используется, включить удержание экрана
;
; Код "\" - не используется, отключить удержание экрана
;
; Код "=" - не используется, Alternate keypad
;
; Код ">" - не используется, Exit alternate keypad
;
; Код "<" - не используется, включить/выключить поддержку кодов ANSI
;
; b# - не используется, Foreground color (расширение GDOS/TOS)
;
; c# - не используется,	Background color (расширение GDOS/TOS)
;
; d	Clear to start of screen	Clear screen from the cursor up to the home position. (расширение GDOS/TOS)
;
; Код "e" - Enable cursor (расширение GDOS/TOS)
;
; Код "f" - Disable cursor (расширение GDOS/TOS)
;
; Код "j" - Saves the current position of the cursor in memory. (расширение GDOS/TOS)
;
; Код "k" - Return the cursor to the settings previously saved with j. (расширение GDOS/TOS)
;
; l	Clear line	Erase the entire line and positions the cursor on the left. (расширение GDOS/TOS)
;
; o	Clear to start of line	Clear current line from the start to the left side to the cursor. (расширение GDOS/TOS)
;
; Код "p" - Не используется, Reverse video (расширение GDOS/TOS)
;
; Код "q" - Не используется, Normal video (расширение GDOS/TOS)
;
; Код "v" - Wrap on (расширение GDOS/TOS)
;
; Код "w" - Wrap off (расширение GDOS/TOS)
;
	CPU	8080
	Z80SYNTAX	EXCLUSIVE

; ──────────────────────────────────────────────
RABADR	EQU	0F800H
DOPPPA	EQU	0A000H
K_ORIG	EQU	0		; если 1, то измененный курсор
; ──────────────────────────────────────────────

CHK	MACRO	adr, msg
		IF	adr-$
;			ERROR	msg
		ENDIF
	ENDM

	ORG	RABADR

BASE    EQU	7600H		; ниже D0H байтов - служебные ячейки

EK_ADR  EQU	BASE		; текущий адрес на экране
POSX	EQU	BASE+02H
POSY	EQU	BASE+03H
ESC_FL	EQU	BASE+04H
KBDFLG	EQU	BASE+05H 	; если =0, то есть символ в SYMBUF
RUSLAT	EQU	BASE+06H	; допустимо только 0 или FF  !! Адрес должен быть xx06h иначе править SET_RL !!
LAST_K	EQU	BASE+09H	; эти 2 байта должны следовать подряд
COUNT	EQU	BASE+0AH	; счётчик опросов (вначале 15)
APVFLG	EQU	BASE+0BH	; флаг автоповтора
FRELOC	EQU	BASE+0CH	; эта ячейка не используется

TMPSTK	EQU	BASE+0DH	; временно храним стек при МГ п/п-ммах
POINT	EQU	BASE+14H	; адрес откуда произошёл RST_30H
XYSTOR	EQU	POINT		; Сохраненные координаты курсора
R_HL	EQU	BASE+16H
SASTOR	EQU	R_HL		; Сохраненный адрес курсора
R_BC	EQU	BASE+18H
CURST	EQU	R_BC		; Отображать/прятать курсор
WRPFLG	EQU	R_BC+1		; Автоперенос строк
R_SP	EQU	BASE+1CH
R_AF	EQU	BASE+1EH	; ниже откладываются AF,HL,DE,BC
STOP_A  EQU	BASE+23H
TMP_COD EQU	BASE+25H
P_JMP	EQU	BASE+26H	; для байта C3H (JMP)
PAR_HL  EQU	BASE+27H
PAR_DE  EQU	BASE+29H
PAR_BC  EQU	BASE+2BH
FLG_P2	EQU	BASE+2DH	; флаг, что есть параметры 2 или 2,3
INV_MG	EQU	BASE+2EH
KNS_RD	EQU	BASE+2FH
KNS_WR	EQU	BASE+30H
RAMTOP	EQU	BASE+31H
COMBUF	EQU	BASE+33H	; буфер ввода директивы
STACK	EQU	BASE+0D0H	; стек монитора

MARGIN_TOP	EQU	3
MARGIN_BOTTOM	EQU	3;?
MARGIN_LEFT	EQU	8
MARGIN_RIGHT	EQU	8;?

SA	EQU	076D0H		; 76D0 начало экранной области
SCBASE  EQU	077C2H		; 77C2 ЛЕВ.ВЕРХН.УГОЛ ЭКР.

VG_75   EQU	0C000H
VT_57   EQU	0E000H

PA	EQU	8000H
PB	EQU	PA+1
PC	EQU	PA+2
PU	EQU	PA+3

PDA	EQU	DOPPPA
PDB	EQU	PDA+1
PDC	EQU	PDA+2
PDU	EQU	PDA+3

; ──────────────────────────────────────────────

LOOP	MACRO	ADDR
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,ADDR
	ENDM

; ──────────────────────────────────────────────

	JP	XF800		; +0
	JP	CONIN 		; +3
	JP	LDBYTE		; +6
	JP	COUT_C		; +9
	JP	WRBYTE		; +C
	JP	COUT_C		; +F   это д.быть PRINT
	JP	STATUS		; +12
	JP	HEX_A 		; +15
	JP	MSGH  		; +18
	JP	XF81B 		; +1B
	JP	ASKCUR		; +1E
	JP	RD_SCR		; +21
	JP	RD_BLK		; +24
	JP	WR_BLK		; +27
	JP	CHSUMM		; +2A
	JP	PUSK_VG		; +2D
ASKTOP: LD	HL,(RAMTOP)	; +30
SETTOP:	LD	(RAMTOP),HL	; +33
	RET

; ──────────────────────────────────────────────

AFB86:	LD	C,(HL)			; 10 bytes
	CALL	WRBYTE
	CALL	AF999
	JP	AFB86

; ──────────────────────────────────────────────

XF800:	LD	HL,BASE-1
	LD	(RAMTOP),HL
	LD	SP,HL

	LD	A,8AH
	LD	(PU),A

	INC	HL			; LD HL,BASE
	LD	C,L			; 0
	LD	DE,COMBUF+2CH
	CALL	DIR_F

	XOR	A
	LD	(WRPFLG), A

	LD	A, 99H
	LD	(CURST), A
	CALL	PUSK_VG

	CALL	RST_18
TITR:	DB	1FH,'radio-86r','k' + 80H

	LD	HL,1D2AH
	LD	(KNS_RD),HL

	CHK	0f86ch, "* Standard subroutine WARMST shifted ! *"

WARMST:				; Warm_BOOT
	LD	SP,STACK

	LD	A,90H
	LD	(PDU),A

	CALL	RST_18
PROMPT:	DB	13,10,'-','-','>'+128

	CALL	GETLIN

	LD	HL,WARMST
	PUSH	HL


	CALL	GETPRM
	LD	HL,COMBUF
	LD	A,(HL)
	LD	HL,(PAR_BC)		; Z80: LD BC,(PAR_BC)
	LD	C,L
	LD	B,H
	LD	HL,(PAR_DE)		; Z80: LD DE,(PAR_DE)
	EX	DE,HL
	LD	HL,(PAR_HL)

	SUB	'C'			;CP	'C'
	JP	Z,DIR_C
	DEC	A			;CP	'D'
	JP	Z,DIR_D
	SUB	2			;CP	'F'
	JP	Z,DIR_F
	DEC	A			;CP	'G'
	JP	Z,DIR_G
	SUB	2			;CP	'I'
	JP	Z,DIR_I
	SUB	3			;CP	'L'
	JP	Z,DIR_L
	DEC	A			;CP	'M'
	JP	Z,DIR_M
	SUB	2			;CP	'O'
	JP	Z,DIR_O
	SUB	3			;CP	'R'
	JP	Z,DIR_R
	DEC	A			;CP	'S'
	JP	Z,DIR_S
	DEC	A			;CP	'T'
	JP	NZ,ERROR

; ──────────────────────────────────────────────

DIR_T:	LD	A,(HL)			; 9 bytes
	LD	(BC),A
	INC	BC
	CALL	AF999
	JP	DIR_T

; ──────────────────────────────────────────────
; Заполняет область памяти с HL по DE байтом C
; ВХОД:
;	HL	- начальный адрес
;	DE	- конечный адрес
;	C	- байт для записи
; ВЫХОД:

; ИЗМЕНЯЕТ:
;	AF, HL
; ──────────────────────────────────────────────

DIR_F:
	LD	(HL),C
	CALL	AF999
	JP	DIR_F

; ──────────────────────────────────────────────
; Возвращает в HL координаты курсора
; ВХОД:
;	Нет
; ВЫХОД:
;	H - Y
;	L - X
; ИЗМЕНЯЕТ:
;	HL
; ──────────────────────────────────────────────

ASKCUR:	LD	HL,(POSX)		; 4 bytes
	RET

; ──────────────────────────────────────────────

MSGCPM:	EX	DE, HL
	LD	B, '$'
	DB	11h			; LD DE, ...
MSGH:	LD	B, 0			; 13 bytes
	LD	A,(HL)
	CP	B			; CP 0
	RET	Z
	CALL	SCOUTA
	INC	HL
	RET	M			; RET if high bit set
	JP	MSGH

; ──────────────────────────────────────────────
	CHK	0F8EEH, "* Internal subroutine GETLIN shifted ! *"

GETLIN:	LD	HL,COMBUF
	LD	D,H
	LD	E,L
AF8F1:
	XOR	A
	LD	B,A		; чтобы на выходе получить флаг пустой строки
	CALL	SET_RL
AF8F3:	CALL	CONIN		; используется в DIR_M
	CP	7FH
	JP	Z,BAKSTP
	LD	(HL),A
	CALL	SCOUTA
	CP	13
	JP	Z,AF91A
	CP	'.'
	JP	Z,WARMST
	LD	B,E			; B=76H --> бит D7=0
	LD	A, (COMBUF & 00FFh)+31
	CP	L
	JP	Z,ERROR
	INC	HL
	JP	AF8F3


; ──────────────────────────────────────────────
; Ввод символа без ожидания с проверкой нажатия Ctrl-C. 
; При нажатии Ctrl-C выход в МОНИТОР с переинцициализацией ВГ.
; ВХОД:
;	Нет
; ВЫХОД:
;	A=0FFH - не нажата
;	A=0FEH - РУС/ЛАТ
;	A - код клавиши
; ИЗМЕНЯЕТ:
;	AF		 TODO: проверить, что изменяет XF81B и PUSK_VG
; ──────────────────────────────────────────────

CHK_F4:	CALL	XF81B			; 12 bytes
	CP	3
	RET	NZ
	CALL	PUSK_VG
	JP	ERROR

; ──────────────────────────────────────────────

AF91A:	SUB	B			; 2 bytes
	RET

; ──────────────────────────────────────────────

	CHK	0F92cH, "* Internal subroutine GETPRM shifted ! *"

; ──────────────────────────────────────────────
; Читает аргументы со второй позиции буфера команды в регистры HL, DE, BC
; Разделителями считаются ',' и ' '. Конец данных - CR
; ВХОД:
;	Нет
; ВЫХОД:
;	HL	- первый аргумент
;	DE	- первый аргумент, если один параметр в строке, иначе второй аргумент
;	BC	- третий аргумент
;	При ошибке разбора выходит в МОНИТОР
; ИЗМЕНЯЕТ:
;	AF, HL, DE, BC
; ──────────────────────────────────────────────

GETPRM:	LD	HL,PAR_HL	; Обнуляем параметры
	LD	DE,FLG_P2
	LD	C,0
	CALL	DIR_F

;if	high (BASE+34H) eq high BASE
	LD	E,34H
;    else
;	.printx *      Wrong BASE (Low BASE need be < 0E0H) !
;endif
	CALL	GET_HL
	LD	(PAR_HL),HL
	LD	(PAR_DE),HL
	RET	C
	LD	(FLG_P2),A

	CALL	GET_HL
	LD	(PAR_DE),HL
	RET	C

	CALL	GET_HL
	LD	(PAR_BC),HL
	RET	C
	JP	ERROR

; ──────────────────────────────────────────────

AFE97:	PUSH	HL			; 27 bytes
	LD	HL,7 << 8 + 1
AFE9C:	LD	A,L
	RRCA
	LD	L,A
	CPL
	LD	(PA),A
	LD	A,(PB)
	CPL
	OR	A
	JP	NZ,AFEB3
	DEC	H
	JP	P,AFE9C
AFEAF:	LD	A,0FFH
	POP	HL
	RET

; ──────────────────────────────────────────────

XF81B:	LD	A,(PC)		; 30 bytes
	RLA
	LD	A,0FEH
	RET	NC
AFE7D:
	XOR	A
	LD	(PA),A
	LD	A,(RUSLAT)
	AND	00000001B
	OR	00000110B	; зажигаем/гасим светодиод
	LD	(PU),A
	LD	A,(PB)
	INC	A
	JP	NZ,AFE97
	DEC	A
	RET

; ──────────────────────────────────────────────

	CHK	0F990H, "* Internal subroutine CMPDH shifted ! *"

CMPDH:	LD	A,H
	CP	D
	RET	NZ
	LD	A,L
	CP	E
	RET

; ──────────────────────────────────────────────

BAKSTP:	LD	A,E			; 15 bytes
	CP	L			; начало буфера ввода ?
	JP	Z,AF8F1
	CALL	RST_18
TZABOJ:	DB	8,' ',8+128
	DEC	HL
	JP	AF8F3

; ──────────────────────────────────────────────

DIR_S:	LD	A,C			; 11 bytes
	CP	(HL)
	CALL	Z,CHXHL_
	CALL	AF996
	JP	DIR_S

; ──────────────────────────────────────────────

	CHK	0F9B0H, "* Internal subroutine CR shifted ! *"

CR:	CALL	RST_18
	DB	13,10 + 80H
	RET

; ──────────────────────────────────────────────

DIR_I:	LD	A,(FLG_P2)		; 46 bytes
	OR	A
	JP	Z,AFA91
	LD	A,E
	LD	(KNS_RD),A
AFA91:	CALL	RD_BLK

	CALL	JJJ2
	EX	DE,HL

	PUSH	BC
	CALL	CHSUMM
	CALL	DIRK1
	POP	DE

	CALL	CMPDH
	RET	Z
	CALL	CHXDE_
ERROR:	CALL	RST_18
	DB	'?'+80H
	JP	WARMST

; ──────────────────────────────────────────────

DIR_L:	CALL	CHXHL_			; 30 bytes
AFA0B:	LD	A,(HL)
	OR	A
	JP	M,AFA15
	CP	20H
	JP	NC,AFA17
AFA15:	LD	A,'.'
AFA17:	CALL	SCOUTA
	CALL	AF996
	LD	A,L
	AND	0FH
	JP	Z,DIR_L
	JP	AFA0B

; ──────────────────────────────────────────────

AFF3B:	LD	A,L			; 23 bytes
	AND	2FH
	LD	L,A
AFF3F:	LD	A,L
	CP	40H
	POP	HL
	RET	P
	PUSH	HL
	LD	L,A
	AND	00FH
	CP	00CH
	LD	A,L
	JP	M,AFF50
	XOR	10H
AFF50:	POP	HL
	RET

; ──────────────────────────────────────────────

CHSUMM:	LD	BC,0			; 23 bytes
AFB19:	LD	A,(HL)
	ADD	A,C
	LD	C,A
	PUSH	AF
	CALL	CMPDH
	JP	Z,POPAF
	POP	AF
	LD	A,B
	ADC	A,(HL)
	LD	B,A
	CALL	AF999
	JP	AFB19

; ──────────────────────────────────────────────

DIR_M:	CALL	JJJ_02			; 22 bytes
	PUSH	HL
	CALL	GETLIN
	POP	HL
	JP	NC,AFA3B
	PUSH	HL
	CALL	GET_HL
	LD	A,L
	POP	HL
	LD	(HL),A
AFA3B:	INC	HL
	JP	DIR_M

; ──────────────────────────────────────────────

DIR_R:
AFA6D:	LD	(PDB),HL
	LD	A,(PDA)
	LD	(BC),A
	INC	BC			; 19 bytes
	CALL	AF999
	JP	AFA6D

; ──────────────────────────────────────────────

DIR_D:	CALL	CHXHL_			; 18 bytes
AF9C8:	CALL	LDXHX_
	CALL	AF996
	LD	A,L
	AND	0FH
	JP	Z,DIR_D
	JP	AF9C8

; ──────────────────────────────────────────────

KEY_FE:	LD	A,(PC)			; 17 bytes
	RLA
	JP	NC,KEY_FE		; ждём отпускания РУС/ЛАТ
	LD	A,(RUSLAT)
	CPL
	CALL	SET_RL
	JP	AFE1A

; ──────────────────────────────────────────────

BYTE3:	LD	A,C			; 18 bytes
	SUB	20H
	LD	C,A
AFD77:	DEC	C
	LD	A,3
	JP	M,SETESC
	PUSH	BC
	CALL	DOWN
	POP	BC
	JP	AFD77

; ──────────────────────────────────────────────

RD_SCR: PUSH	HL			; 7 bytes
	LD	HL,(EK_ADR)
	LD	A,(HL)
	POP	HL
	RET


; ──────────────────────────────────────────────

RST_18:	EX	(SP),HL			; 6 bytes
	CALL	MSGH
	EX	(SP),HL
	RET

; ──────────────────────────────────────────────

RD_BLK:	CALL	LDBCSS
	PUSH	HL
	ADD	HL,BC
	EX	DE,HL
	CALL	LDBCBS
	POP	HL
	ADD	HL,BC
	EX	DE,HL
	PUSH	HL
	CALL	LD_BLK
	CALL	LDBCSS		; с поиском СБ
	POP	HL
	DB	06h		; LD B, ..

SET_RL:	LD	(RUSLAT),A		; Т.к. адрес RUSLAT xx06h, то предыдущий трюк с LD B, .. повторится..

; ──────────────────────────────────────────────

	CHK	0FACEH, "* Internal subroutine PUSK_VG shifted ! *"
PUSK_VG:			; 1001.0011
				; 1100.0011

	PUSH	HL
	LD	HL,VG_75+1
	LD	(HL),0   	; reset commando
	DEC	HL       	; адрес VG_75
	LD	(HL),04DH	; 0.1001101  77+1 знакомест
	LD	(HL),01DH	; 00.011101  29+1 строк

	LD	A, (CURST)	; 99H - включен A9H выключен
        LD	(HL),A		; 1001.1001  9 +1 линия подчерк.
        			; 9+1 линий в знакоместе
	if	K_ORIG
	LD	(HL),93H
	else
	LD	(HL),0C3H
	endif

	INC	HL		; адрес VG_75+1
	LD	(HL),27H	; start display commando
	LD	A,(HL)		; read status
AFAE1:	LD	A,(HL)		; read status
	AND	20H		; mask 'Interrupt request flag'
	JP	Z,AFAE1         ; ждем конца строки
	LD	HL,VT_57+8
	LD	(HL),80H
	LD	L,4             ; VT_57+04
	LD	(HL),SA & 00FFh 	; 0D0H
	LD	(HL),SA>>8	; 076H
	INC	L               ; адрес VT_57+5
	LD	(HL),23H
	LD	(HL),49H
	LD	L,8             ; VT_57+8
	LD	(HL),0A4H
	POP	HL
	RET

; ──────────────────────────────────────────────

DIR_O:	LD	A,C
	OR	A
	JP	Z,AFB35
	LD	(KNS_WR),A
AFB35:	PUSH	HL
	CALL	CHSUMM
	POP	HL
	
	CALL	JJJ2
	EX	DE,HL
	
	PUSH	HL
	CALL	DIRK1
	POP	HL
WR_BLK:
	PUSH	BC		; КС

	LD	BC,0		; выводим 256 байтов 00 (пилотон)
AFB4D:	CALL	WRBYTE
	EX	(SP),HL 	; это задержка 38 тактов
	EX	(SP),HL
	DEC	B
	JP	NZ,AFB4D

	LD	C,0E6H  	; выводим синхробайт E6
	CALL	WRBYTE

	CALL	WR_HL		; выводим НА
	EX	DE,HL
	CALL	WR_HL		; выводим КА

	EX	DE,HL
	CALL	AFB86		; выводим блок

	LD	HL,0
	CALL	WR_HL		; выводим 2 байта 00

	LD	C,0E6H  	; снова выводим с/байт E6
	CALL	WRBYTE

	POP	HL
	CALL	WR_HL		; выводим КС

	JP	PUSK_VG


; ──────────────────────────────────────────────

; Вводит в HL HEX-число из строки по (DE) до нажатия ВК

GET_HL:	LD	HL,0		; 48 bytes
AF95D:	LD	A,(DE)		; Выход: CY=1 если разделитель <ВК>
	INC	DE
	CP	13
	SCF
	RET	Z
	CP	','
	RET	Z
	CP	20H
	JP	Z,AF95D

	LD	BC,ERROR
	PUSH	BC

	SUB	'0'
	RET	C		; JP C,ERROR

	CP	9+1
	JP	C,AF982

	CP	'A'-'0'
	RET	C		; JP C,ERROR

	CP	'F'-'0'+1
	RET	NC		; JP NC,ERROR

	SUB	'A'-('9'+1)
AF982:
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	RET	C		; JP C,ERROR

	OR	L
	LD	L,A

	POP	AF
	JP	AF95D

; ──────────────────────────────────────────────

; ──────────────────────────────────────────────
; Печать перевода строки, числа из HL в 16-ричном формате, пробела,
; перевода строки, числа из BC в 16-ричном формате, пробела
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B, DE, HL
; ──────────────────────────────────────────────

JJJ2:	CALL	CHXHL_

; ──────────────────────────────────────────────
; Печать перевода строки, числа из BC в 16-ричном формате и пробела
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B, DE, HL
; ──────────────────────────────────────────────

DIRK1:	LD	D,B
	LD	E,C

; ──────────────────────────────────────────────
; Печать перевода строки, числа из DE в 16-ричном формате и пробела
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B, DE, HL
; ──────────────────────────────────────────────

CHXDE_:	EX	DE,HL

	CHK	0FB78H, "* Internal subroutine CHXHL_ shifted ! *"

; ──────────────────────────────────────────────
; Печать перевода строки, числа из HL в 16-ричном формате и пробела
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B
; ──────────────────────────────────────────────

CHXHL_: CALL	CR

; ──────────────────────────────────────────────
; Печать числа из HL в 16-ричном формате и пробела
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

HEXHL_:	LD	A,H
	CALL	HEX_A
	LD	A,L
	JP	HEXABL

; ──────────────────────────────────────────────

DIR_C:	LD	A,(BC)			; 19 bytes
	CP	(HL)
	JP	Z,AF9E6
	CALL	JJJ_02
	LD	A,(BC)
	CALL	HEXABL
AF9E6:	INC	BC
	CALL	AF996
	JP	DIR_C

; ──────────────────────────────────────────────

AFEF3:	LD	A,H			; 7 bytes
	LD	HL,TABK1
	JP	AFEFE

; ──────────────────────────────────────────────
; Загрузка A без поиска синхробайта
; ВХОД:
;	Нет
; ВЫХОД:
;	A	- загруженный байт
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

LDBS:	LD	A,8

; ──────────────────────────────────────────────
; Загрузка A
; ВХОД:
;	A=008H	- без поиска синхробайта
;	A=0FFH	- с поиском синхробайта
; ВЫХОД:
;	A	- загруженный байт
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

LDBYTE: PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	D,A
AFB9C:	LD	A,80H
	LD	(VT_57+8),A

	LD	HL,0
	LD	C,L
	ADD	HL,SP
	LD	(TMPSTK),HL

	LD	SP,0
	LD	A,(PC)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	1
	LD	E,A
AFBB7:	POP	AF
	LD	A,C
	AND	07FH
	RLCA
	LD	C,A
	LD	H,0
AFBBF:	DEC	H
	JP	Z,AFC34
	POP	AF		; Регенерация ОЗУ
	LD	A,(PC)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	1
	CP	E
	JP	Z,AFBBF
	OR	C
	LD	C,A
	DEC	D
	LD	A,(KNS_RD)
	JP	NZ,AFBDC
	SUB	012H
AFBDC:	LD	B,A
AFBDD:	POP	AF		; Регенерация ОЗУ
	DEC	B
	JP	NZ,AFBDD
	INC	D
	LD	A,(PC)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	001H
	LD	E,A
	LD	A,D
	OR	A
	JP	P,AFC0B
	LD	A,C
	CP	0E6H		; ПРЯМОЙ СИНХРО-БАЙТ ?
	JP	NZ,AFBFF
	XOR	A
	LD	(INV_MG),A	; ПРИЗНАК ИНВЕРСИИ МАГНИТОФОНА
	JP	AFC09

; ──────────────────────────────────────────────

AFBFF:	CP	19H		; ОБРАТНЫЙ С/БАЙТ
	JP	NZ,AFBB7	; 58 bytes
	LD	A,0FFH
	LD	(INV_MG),A 	; Tape inverse flag
AFC09:	LD	D,9
AFC0B:	DEC	D
	JP	NZ,AFBB7

	LD	HL,VT_57+4
	LD	(HL), SA & 00FFH		; 0D0H
	LD	(HL), SA >>8		; 076H
	INC	HL
	LD	(HL),023H
	LD	(HL),049H
	LD	A,27H			; start display commando
	LD	(VG_75+1),A
	LD	A,0E0H			; reset count
	LD	(VG_75+1),A
	LD	L,8
	LD	(HL),0A4H

	LD	HL,(TMPSTK)
	LD	SP,HL

	LD	A,(INV_MG)
	XOR	C			; with Tape Inverse flag
	JP	POPREG

; ──────────────────────────────────────────────


WR_HL:	LD	C,H
	CALL	WRBYTE
	LD	C,L

WRBYTE: PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	A,80H
	LD	(VT_57+8),A
	LD	HL,0
	ADD	HL,SP		; временно храним стек
	LD	SP,0		; для регенерации
	LD	D,8
AFC58:	POP	AF
	LD	A,C
	RLCA
	LD	C,A
	LD	A,1
	XOR	C
	LD	(PC),A
	LD	A,(KNS_WR)
	LD	B,A
AFC66:	POP	AF
	DEC	B
	JP	NZ,AFC66
	XOR	A
	XOR	C
	LD	(PC),A
	DEC	D
	LD	A,(KNS_WR)
	JP	NZ,AFC7A
	SUB	14
AFC7A:	LD	B,A

AFC7B:	POP	AF		; подъем стека на [рег.B] ячеек
	DEC	B
	JP	NZ,AFC7B
	INC	D
	DEC	D
	JP	NZ,AFC58

	LD	SP,HL
	LD	HL,VT_57+4
	LD	(HL), SA & 00FFh	; 0D0H
	LD	(HL), SA >> 8	; 076H
	INC	HL		; VT_57+5
	LD	(HL),23H
	LD	(HL),49H
	LD	A,27H		; start display commando
	LD	(VG_75+1),A	; 001.sss.bb    001.001.11
	LD	A,0E0H		; сброс счетчиков строк и знакомест ???
	LD	(VG_75+1),A
	LD	L,8
	LD	(HL),0A4H	; VT_57+8
POPREGA:
	POP	AF
POPREG: POP	HL
	POP	DE
	POP	BC
LD_BAK:	RET

; ──────────────────────────────────────────────
; Печать числа из A в 16-ричном формате
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

HEX_A:	PUSH	AF			; 23 bytes
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	NIBBLE
	POP	AF
NIBBLE:	AND	0FH
	CP	10
	SBC	A,2FH
	DAA

; ──────────────────────────────────────────────
; Печать символа из A
; ВХОД:
;	A	- символ для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

SCOUTA:
	PUSH	BC		; 10 bytes
	LD	C,A
	DB	06h		; LD B,.. ;JP	COUT_C2

; ──────────────────────────────────────────────
; Печать символа из C
; ВХОД:
;	C	- символ для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

;BUG Для эмуляции VT-52 необходимо игнорировать код NUL (00H) и DEL (7FH). С последним проблеммы, т.к. в РК86 это квадрат.

COUT_C:	PUSH	BC
COUT_C2:
	PUSH	DE
	PUSH	HL
	PUSH	AF

	CALL	STATUS
	LD	HL,TOBACK
	PUSH	HL
	LD	HL,(POSX)
	EX	DE,HL
	LD	HL,(EK_ADR)
	LD	A,(ESC_FL)
	OR	A
	JP	Z,NO_ESC	; BUG Для VT-52 факт обработки ESC-последовательности не значит, что он игнорирует контрольные коды
	DEC	A
	JP	Z,EscapeHandler	; если второй байт ('Y')
	DEC	A
	JP	Z,BYTE3		; если третий байт
	LD	A,C		; четвёртый байт
	SUB	20H
	LD	C,A
AFCDD:	DEC	C
	JP	M,EscapeHandlerEnd         ; СБРОС ESC_FL И ВЫХОД
	PUSH	BC
	CALL	RIGHT
	POP	BC
	JP	AFCDD

; ──────────────────────────────────────────────

NO_ESC:	LD	A,C
	AND	7FH
	LD	C,A
	SUB	1FH		;CP	1FH
	JP	Z, CLS
	ADD	A, 4		;CP	1BH
	JP	Z,EscapeHandlerStart
	INC	A		;CP	1AH
	JP	Z,DOWN
	INC	A		;CP	19H
	JP	Z,UP
	INC	A		;CP	18H
	JP	Z,RIGHT
	ADD	A, 18H-0DH	;CP	0DH
	JP	Z,COD_0D
	INC	A		;CP	0CH
	JP	Z,HOME
	ADD	A, 2		;CP	0AH
	JP	Z,LF
	INC	A		;CP	09H
	JP	NZ,skip_TAB

; ──────────────────────────────────────────────
TAB:	LD	D, 0
	CALL	SUBHLDE
	ADD	A, E
	ADD	A, 8
	AND	11111000b
	LD	D, 0
	LD	E, A
	ADD	HL, DE
	RET

skip_TAB:
	INC	A		;CP	08H
	JP	Z,LEFT
	INC	A
	JP	NZ,skip_BEEP

; ──────────────────────────────────────────────
; Подача звукового сигнала
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, BC
; ОПИСАНИЕ:
; ──────────────────────────────────────────────

BEEP:	LD	BC,05F0H		; 20 bytes
SND_BC:	LD	A,B
BPLOO1:	EI
	DEC	A
	JP	NZ,BPLOO1
	LD	A,B
BPLOO2:	DI
	DEC	A
	JP	NZ,BPLOO2
	DEC	C
	JP	NZ,SND_BC
	RET

skip_BEEP:

	LD	(HL),C		; Видимый на экране символ
	JP	RIGHT

; ──────────────────────────────────────────────
; Возврат каретки
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
; 	HL, BC, AF
; ОПИСАНИЕ:
;	Курсор перемещается в начало текущей строки.
; ──────────────────────────────────────────────

COD_0D:	LD	A,L		; 13 bytes
	SUB	E
	JP	NC,AFDF9
	DEC	H
AFDF9:	LD	L,A
	LD	BC,8
	LD	E,C
	ADD	HL,BC
	RET

; ──────────────────────────────────────────────
; Перевод строки
; ВХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ИЗМЕНЯЕТ:
; 	DE, HL, BC, AF
; ОПИСАНИЕ:
;	Курсор перемещается на одну строку вниз в ту же позицию.
;	Если курсор был на нижней строке, то он там и остается,
;	а содержимое экрана сдвигается вверх на одну строку.
;	Информация, находившаяся на первой строке экрана, теряется.
;	Снизу добавляется пустая строка.
; ──────────────────────────────────────────────

LF:	LD	A,D
	CP	MARGIN_TOP+24	; мы на последней строке ?
	JP	NZ,DOWN		; если не на последней строке

	PUSH	HL		; РОЛИК ЭКРАНА
	PUSH	DE
	LD	HL,SCBASE+78
	LD	DE,SCBASE
	LD	BC,25*78
MOVLOO:	LD	A,(HL)		; пересылка блока размером [BC]
	LD	(DE),A		; (HL) --> (DE)
	INC	HL
	INC	DE
	LOOP	MOVLOO
	POP	DE
	POP	HL
	RET

; ──────────────────────────────────────────────

AFEB3:	LD	L,20H			; 47 bytes
AFEB5:	LD	A,(PB)
	CPL
	OR	A
	JP	Z,AFEAF
	DEC	L
	JP	NZ,AFEB5
	LD	L,8
AFEC3:	DEC	L
	RLCA
	JP	NC,AFEC3
	LD	A,H
	LD	H,L
	LD	L,A
	CP	1
	JP	Z,AFEFA
	JP	C,AFEF3
	RLCA
	RLCA
	RLCA
	ADD	A,20H
	OR	H
	CP	5FH
	JP	NZ,AFF06
	LD	A,20H
	POP	HL
	RET

; ──────────────────────────────────────────────

AFE2A:	DEC	H			; в рег.A=код клав, в рег.H- COUNT
	JP	NZ,AFE21		; 39 bytes
	INC	A
	JP	Z,AFE22			; если код FF, то сброс флагов
	INC	A
	JP	Z,KEY_FE		; если код FE (RUSLAT)

	PUSH	BC			; КЛИК
	LD	BC,5003H
	CALL	SND_BC
	POP	BC

	LD	A,(APVFLG)
	LD	H,0E0H
	DEC	A
	LD	(APVFLG),A
	JP	Z,AFE4C
	LD	H,40H
AFE4C:	LD	A,0FFH
	JP	AFE22

; ──────────────────────────────────────────────

; После 15 вызовов STATUS при нажатой клавише выставляется флаг KBDFLG

STATUS:	LD	A,(PC)		; 38 bytes
	RLA
	JP	NC,AFE0E	; если нажат RUS/LAT
	LD	A,(KBDFLG)
	OR	A
	RET	NZ		; если в SYMBUF уже есть символ
AFE0E:	PUSH	HL
	LD	HL,(LAST_K)
	CALL	XF81B
	CP	L
	LD	L,A
	JP	Z,AFE2A
AFE1A:	LD	A,1
	LD	(APVFLG),A
	LD	H,15H		; число опросов, чтобы зафиксировать код
AFE21:	XOR	A
AFE22:	LD	(LAST_K),HL
	POP	HL
	LD	(KBDFLG),A
	RET

; ──────────────────────────────────────────────

AFF1A:	LD	A,(RUSLAT)		; 33 bytes
	OR	A
	JP	Z,AFF2A
	LD	A,L
	CP	40H
	JP	M,AFF2A
	OR	20H
	LD	L,A
AFF2A:	LD	A,H
	AND	20H
	JP	NZ,AFF3F
	LD	A,L
	CP	40H
	JP	M,AFF3B
	LD	A,L
	XOR	20H
	POP	HL
	RET

; ──────────────────────────────────────────────

AFEFA:	LD	A,H			; 32 bytes
	LD	HL,TABK2
AFEFE:	ADD	A,L
	LD	L,A
	LD	A,(HL)
	CP	40H
	POP	HL
AFF04:	RET	C
	PUSH	HL
AFF06:	LD	L,A
	LD	A,(PC)
	LD	H,A
	AND	40H
	JP	NZ,AFF1A
	LD	A,L
	CP	40H
	JP	M,AFF3F
	AND	1FH
	POP	HL
	RET

; ──────────────────────────────────────────────

AFC34:	LD	HL,(TMPSTK)		; 18 bytes
	LD	SP,HL
	CALL	PUSK_VG
	LD	A,D
	OR	A
	JP	P,ERROR
	CALL	CHK_F4
	JP	AFB9C



; ──────────────────────────────────────────────

JJJ_02:	CALL	CHXHL_			; 12 bytes

; ──────────────────────────────────────────────
; Печать числа из ячейки памяти HL в 16-м формате и пробела
; ВХОД:
;	HL	- адрес байта числа для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

LDXHX_:	LD	A,(HL)

; ──────────────────────────────────────────────
; Печать числа из A в 16-м формате и пробела
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

HEXABL:	CALL	HEX_A

; ──────────────────────────────────────────────
; Печать пробела
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	A
; ──────────────────────────────────────────────

SPACE:	LD	A,20H
	JP	SCOUTA

; ──────────────────────────────────────────────
; Загрузка BC с поиском синхробайта
; ВХОД:
;	Нет
; ВЫХОД:
;	BC	- загруженные байта
; ИЗМЕНЯЕТ:
;	AF, BC
; ──────────────────────────────────────────────

LDBCSS: LD	A, 0FFH			; 14 bytes
	DB	1			; LD BC, ..

; ──────────────────────────────────────────────
; Загрузка BC без поиска синхробайта
; ВХОД:
;	Нет
; ВЫХОД:
;	BC	- загруженные байта
; ИЗМЕНЯЕТ:
;	AF, BC
; ──────────────────────────────────────────────

LDBCBS:	LD	A, 8

; ──────────────────────────────────────────────
; Загрузка BC
; ВХОД:
;	A=008H	- без поиска синхробайта
;	A=0FFH	- с поиском синхробайта
; ВЫХОД:
;	BC	- загруженные байта
; ИЗМЕНЯЕТ:
;	AF, BC
; ──────────────────────────────────────────────

_LD_BC:	CALL	LDBYTE
	LD	B, A
	CALL	LDBS
	LD	C, A
	RET

; ──────────────────────────────────────────────

AF996:	CALL	CHK_F4			; 11 bytes
AF999:	CALL	CMPDH
	INC	HL
	RET	NZ
	DEC	HL
POPAF:	POP	AF
	RET

; ──────────────────────────────────────────────
;BDOS function 6 (C_RAWIO) - Direct console I/O
;Supported by: CP/M 1.4 and later, with variations
;Entered with C=6, E=code. Returned values (in A) vary.
;
;E=0FFh
;Return a character without echoing if one is waiting; zero if none is available. In MP/M 1, this works like E=0FDh below and waits for a character.
;Values of E not supported on a particular system will output the character. Under CP/M 2 and lower, direct console functions may interact undesirably with non-direct ones, since certain buffers may be bypassed. Do not mix them.
; ──────────────────────────────────────────────

FUNC06:	INC	E		; Test for 0FFH
	JP	NZ,0F809H
	CALL	0F812H
	RET	Z

; ──────────────────────────────────────────────
; Ввод символа с ожиданием. 
; ВХОД:
;	Нет
; ВЫХОД:
;	A - введенный символ
; ИЗМЕНЯЕТ:
;	AF		 TODO: проверить, что изменяет STATUS
; ──────────────────────────────────────────────

CONIN:	CALL	STATUS
	OR	A
	JP	Z,CONIN
	XOR	A
	LD	(KBDFLG),A
	LD	A,(LAST_K)
	RET


; ──────────────────────────────────────────────

TABK1:	DB	0CH,1FH,1BH,0,1,2,3,4,5	  ; 9 bytes

; ──────────────────────────────────────────────

TOBACK: LD	(EK_ADR),HL		; 23 bytes
	EX	DE,HL
	LD	(POSX),HL
	LD	A,80H
	LD	(VG_75+1),A
	LD	A,L
	LD	(VG_75),A
	LD	A,H
	LD	(VG_75),A
	JP	POPREGA

; ──────────────────────────────────────────────

DIR_G:
;	PUSH	DE
;	LD	DE, 0100H
;	CALL	CMPDH
;	CALL	Z, INIT
;	POP	DE
	JP	(HL)			; 1 bytes

; ──────────────────────────────────────────────

LD_BLK:	CALL	LDBS			; 10 bytes
	LD	(HL),A
	CALL	AF999
	JP	LD_BLK

; ──────────────────────────────────────────────
; Обработчик ESC-последовательности
; ВХОД:
;	C=ESC-код
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B, DE, HL
; ОПИСАНИЕ:
;	Поддерживаемые ESC-последовательности:
;		ESC A	- Cursor Up
;		ESC B	- Cursor Down
;		ESC C	- Cursor Right
;		ESC D	- Cursor Left
;		ESC E	- Clear screen (GEMDOS/TOS extension)
;		ESC F	- Alternate charset not implemented
;		ESC G	- Standard charset not implemented
;		ESC H	- Cursor Home
;		ESC I	- Reverse Line Feed
;		ESC J	- Erase to End Of Screen
;		ESC K	- Erase to End Of Line
;		ESC L	- Insert line (not VT52)
;		ESC M	- Delete line (not VT52)
;		ESC Y	- Direct Cursor Addressing
;		ESC Z	- Identify Terminal Type
;		ESC [	- Enter Hold Screen Mode
;		ESC \	- Exit Hold Screen Mode
;		ESC e	- Enable cursor (GEMDOS/TOS extension)
;		ESC f	- Disable cursor(GEMDOS/TOS extension)
;		ESC j	- Save cursor (GEMDOS/TOS extension)
;		ESC k	- Restore cursor(GEMDOS/TOS extension)
;		ESC p	- Inverse video (GEMDOS/TOS extension) not implemented
;		ESC q	- Normal video(GEMDOS/TOS extension) not implemented
;		ESC w	- Wrap on (GEMDOS/TOS extension)
;		ESC v	- Wrap off (GEMDOS/TOS extension)
;	Здесь используется немного нестандартная схема выбора обработчика.
;	Обработчики не вызываются для каждого символа отдельно, а встроены
;	непосредственно в логику ветвления. Для этого символ в A
;	уменьшаетя на величину 'w' (максимальный управляющий символ).
;	После чего происходит для каждого символа увеличение на дельту.
;	По JP NZ осуществляется обход кода обработчика, если он нам не нужен.
;	Сам обработчик должен обеспечить только, чтобы регистр A на выходе
;	был меньше, чем 0A0H. Тогда не будет фальш-сработок. При вызове обработчика
;	будет осущетсвляться перебор и обход кода всех обработчисков и в конце будет
;	возврат через EscapeHandlerEnd. Такой метод позволит сэкономить на команде
;	RET для каждого обработчика. Суммарно это около 20 байт экономии. Чем
;	больше обработчиков, тем больше экономия от такого подхода.
; ──────────────────────────────────────────────

EscapeHandler:
	LD	A,C
	PUSH	HL
	LD	HL, EscapeHandlerEnd
	EX	(SP), HL
	SUB	'w'		;CP	'w'
	JP	NZ, skip_ESC_w

	;esc_w
ESC_w:	XOR	A
	LD	(WRPFLG), A

skip_ESC_w:
	INC	A		;CP	'v'
	JP	NZ, skip_ESC_v

	;esc_v
ESC_v:	LD	A, 0FFh
	LD	(WRPFLG), A

skip_ESC_v:
	ADD	A, 'v'-'k'	;CP	'k'
	JP	NZ, skip_ESC_k

; ──────────────────────────────────────────────
; Восстановить сохраненные координаты курсора
; ВХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ВЫХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE
; ──────────────────────────────────────────────

CursorRestore:
	LD	HL, (XYSTOR)
	EX	DE, HL
	LD	HL, (SASTOR)
	EX	DE, HL

skip_ESC_k:
	INC	A		;CP	'j'
	JP	NZ, skip_ESC_j

; ──────────────────────────────────────────────
; Сохранить текущие координаты курсора
; ВХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ВЫХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

CursorSave:
	LD	(SASTOR), HL
	EX	DE, HL
	LD	(XYSTOR), HL
	EX	DE, HL

skip_ESC_j:
	ADD	A, 'j'-'f'	;CP	'f'
	JP	NZ, skip_ESC_f

	;esc_f
ESC_f:	LD	A, 0A9H
	LD	(CURST), A

skip_ESC_f:
	INC	A		;CP	'e'
	JP	NZ, skip_ESC_e

	;esc_e
ESC_e:	LD	A, 099H
	LD	(CURST), A

skip_ESC_e:
	ADD	A, 'e'-'Z'	;CP	'Z'
	JP	NZ, skip_ESC_Z
	;esc_Z

skip_ESC_Z:
	INC	A		;CP	'Y'
	JP	NZ, skip_ESC_Y
	;esc_Y

	CALL	HOME
	INC	A		;LD	A,2; ПРИНЯТО 2 БАЙТА ESC,'Y'

; ──────────────────────────────────────────────
; Запуск обработчика ESC-символа
; ВХОД:
;	A=0
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B
; ──────────────────────────────────────────────

EscapeHandlerStart:
	INC	A		; LD A, 1 - для EscapeHandlerStart и LD A, 2 - для EscapeHAndler
	DB	06H		; LD B, ... функционально JP SETESC

; ──────────────────────────────────────────────
; Завершение обработки ESC-последовательности
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

EscapeHandlerEnd:
	XOR	A		; LD A, 0

; ──────────────────────────────────────────────
; Установить режим обработки ESC-последовательности
; ВХОД:
;	A=режим
;		0 - завершить обработку последовательности
;		1 - обработка кода ESC-последовательности
;		2 - обработка первого символа Y-последовательности
;		3 - обработка второго символа Y-последовательности
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

SETESC:	LD	(ESC_FL),A
	RET

skip_ESC_Y:
	ADD	A, 'Z'-'M'	;CP	'M'
	JP	NZ, skip_ESC_M
	;esc_M

skip_ESC_M:
	INC	A		;CP	'L'
	JP	NZ, skip_ESC_L
	;esc_L

skip_ESC_L:
	INC	A		;CP	'K'
	JP	NZ, skip_ESC_K

	;esc_K

ESC_K:	PUSH	HL
	PUSH	DE
KLOOP:	CALL	SPACE
	LD	A, E
	CP	8+63		; последняя колонка
	JP	NZ, KLOOP
	POP	DE
	POP	HL

skip_ESC_K:
	INC	A		;CP	'J'
	JP	NZ, skip_ESC_J

	;esc_J
ESC_J:	PUSH	HL
	PUSH	DE
	LD	D, 0
	CALL	SUBHLDE
	CALL	CLSLOO
	POP	DE
	POP	HL

skip_ESC_J:
	INC	A		;CP	'I'
	JP	NZ, skip_ESC_I

; ──────────────────────────────────────────────
; Обратный перевод строки
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE, AF, BC
; ОПИСАНИЕ:
;	Курсор перемещается вверх на одну строку в ту же позицию. Если
;	курсор был на самой верхней строке, то он не перемещается, но
;	вся информация на экране перемещается вниз на одну строку.
;	Информация с нижней строки теряется, а сверху добавляется новая
;	пустая строка.
; ──────────────────────────────────────────────

RLF:	LD	A,D
	CP	3		; это первая строка ?
	JP	NZ,UP		; если не на первой строке

	PUSH	HL		; РОЛИК ЭКРАНА
	PUSH	DE
	LD	HL,SCBASE+25*78
	LD	DE,SCBASE+78+25*78
	LD	BC,25*78
MOVLO:	LD	A,(HL)		; пересылка блока размером [BC]
	LD	(DE),A		; (HL) --> (DE)
	DEC	HL
	DEC	DE
	LOOP	MOVLO
	POP	DE
	POP	HL

skip_ESC_I:
	INC	A		;CP	'H'
	JP	Z, HOME
	ADD	A, 'H'-'E'	;CP	'E'
	JP	NZ, skip_ESC_E

; ──────────────────────────────────────────────

CLS:	LD	HL,76D0H	; 17 bytes
CLSLOO:	XOR	A
	LD	(HL),A
	INC	HL
	OR	H
	JP	P,CLSLOO
HOME:	LD	DE, MARGIN_TOP << 8 +MARGIN_LEFT
	LD	HL, SCBASE

skip_ESC_E:
	INC	A		;CP	'D'
	JP	NZ, skip_ESC_D

; ──────────────────────────────────────────────
; Перемещение курсора влево
; ВХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ИЗМЕНЯЕТ:
;	AF, HL, DE
; ОПИСАНИЕ:
;	Курсор перемещается на одну позицию влево. Если курсор в начале строки, то
;	он не перемещается. Символ на экране не стирается.
; ──────────────────────────────────────────────

LEFT:
	LD	A,E		; 7 bytes
	CP	MARGIN_LEFT
	JP	Z, skip_ESC_D
	DEC	HL
	DEC	E

skip_ESC_D:
	INC	A		;CP	'C'
	JP	NZ, skip_ESC_C

; ──────────────────────────────────────────────
; Перемещение курсора вправо
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	DE, HL, AF, BC
; ОПИСАНИЕ:
;	Курсор перемещается на одну позицию вправо. Если курсор был в конце
;	строки, то, в зависимости от флага переноса WRPFLG, он остается на
;	месте или перемещается на новую строку в первую позицию. Символы
;	на экране при перемещении курсора не стираются.
; ──────────────────────────────────────────────

RIGHT:	LD	A, (WRPFLG)	;
	INC	A
	JP	Z, WRP
	LD	A,E		; POSX
	CP	MARGIN_LEFT+64	; последняя колонка ?
	RET	Z
WRP:	INC	HL		; следующий экранный адрес
	INC	E		; POSX ++
	LD	A,E		; POSX
	CP	MARGIN_LEFT+64	; последняя колонка ?
	RET	NZ
	LD	E,MARGIN_LEFT	; нач.позиция по X на новой строке
	LD	BC,-64
	ADD	HL,BC		; Вычесть 64 = экр.поз в начало строки

skip_ESC_C:
	INC	A		;CP	'B'
	JP	NZ, skip_ESC_B

; ──────────────────────────────────────────────
; Перемещение курсора вниз
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;
; ОПИСАНИЕ:
; 	Курсор перемещается вниз на одну строку в ту же
;	позицию. Если курсор находится внизу экрана, то
;	курсор остается на той же позиции и скролинг
;	не осуществляется.
; ──────────────────────────────────────────────

DOWN:	LD	A,D
	CP	MARGIN_TOP+24	; последняя строка ?
	RET	Z
	LD	BC,78
	INC	D
	ADD	HL,BC		; Прибавить 78

skip_ESC_B:
	INC	A		; CP	'A'
	RET	NZ

; ──────────────────────────────────────────────
; Перемещение курсора вверх
; ВХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE, BC, AF
; ОПИСАНИЕ:
;	Курсор перемещается вверх на одну строку в ту же позицию. Если курсор
;	находится в самом верху, то он не перемещается.
; ──────────────────────────────────────────────

UP:	LD	A,D		; 10 bytes
	CP	MARGIN_TOP	; это первая строка ?
	RET	Z
	LD	BC,-78
	DEC	D
	ADD	HL,BC		; Вычесть 78
; ──────────────────────────────────────────────

skip_ESC_A:
	RET

; ──────────────────────────────────────────────

SUBHLDE:
	XOR	A
	SUB	E
	LD	E,A
	SBC	A,A
	SUB	D
	LD	D,A
	ADD	HL, DE
	RET

	IF	0

; ──────────────────────────────────────────────
; Блок эмуляции точек входа BIOS и BDOS
; ──────────────────────────────────────────────

BIOSENTRY:
	JP	BDOS		; CBOOT Холодный старт
	JP	WARMST		; WBOOT Теплый старт
	JP	0F812H		; CONST Статус консоли
	JP	0F803H		; CONIN Консольный ввод
	JP	0F809H		; CONOUT Консольный вывод	
BIOSENTRYEND:


; ──────────────────────────────────────────────
; Блок эмуляции точек входа BDOS
; ──────────────────────────────────────────────

BDOS:	LD	HL, 0000H	; Сохраняем стек
	ADD	HL, SP
	LD	(TMPSTK), HL
	LD	SP, STACK
	DEC	C
	JP	M, 0F800H	; Функция 0 P_TERMCPM
	LD	HL, BDOSRET
	PUSH	HL
	LD	A, C
	LD	C, E
	JP	Z, FUNC01	; Функция 1 C_READ
	DEC	A
	JP	Z, 0F809H	; Функция 2 C_WRITE
	SUB	4
	JP	Z, FUNC06	; Функция 6 C_RAWIO
	SUB	3
	JP	Z, MSGCPM	; Функция 9 C_WRITESTR
	DEC	A
	JP	Z, FUNC0A	; Функция 10 C_READSTR
	DEC	A
	JP	Z, 0F812H	; Функция 11 C_STAT
	DEC	A
	JP	NZ, 0F800H	; Функции 13 и выше
	LD	A, 20H		; Функция 12
	LD	B, 00H
	RET

FUNC01:	CALL	0F803H
	JP	SCOUTA

;
;BDOS function 10 (C_READSTR) - Buffered console input
;Supported by: All versions, with variations
;Entered with C=0Ah, DE=address or zero.
;
;This function reads characters from the keyboard into a memory buffer until RETURN is pressed. The Delete key is handled correctly. In later versions, more features can be used at this point; ZPM3 includes a full line editor with recall of previous lines typed.
;
;On entry, DE is the address of a buffer. If DE=0 (in CP/M-86 versions DX=0FFFFh), the DMA address is used (CP/M 3 and later) and the buffer already contains data:
;
;DE=address:                 DE=0 / DX=0FFFFh:
;buffer: DEFB    size        buffer: DEFB    size
        ;DEFB    ?                   DEFB    len
        ;DEFB    bytes               DEFB    bytes
;;The value at buffer+0 is the amount of bytes available in the buffer. Once the limit has been reached, no more can be added, although the line editor can still be used.
;If DE=0 (in 16-bit versions, DX=0FFFFh) the next byte contains the number of bytes already in the buffer; otherwise this is ignored. On return from the function, it contains the number of bytes present in the buffer.
;
;The bytes typed then follow. There is no end marker.
;

FUNC0A:	CALL	GETLIN
	RET

	if 0
	EX	DE, HL
	LD	C, (HL)
	LD	B, 00H
	INC	HL
L008CH:	CALL	0F803H
	CP	7FH
	JP	Z, L00B6H
	CALL	SCOUTA
	CP	0DH
	JP	Z, L00B2H
	CP	03H
	JP	Z, 0F800H
	INC	HL
	LD	(HL), A
	INC	B
	LD	A, C
	CP	B
	JP	NZ, L008CH
	LD	B, C

L00B2H:	INC	DE
	EX	DE, HL
	LD	(HL), B
	RET

L00B6H:	LD	A, B
	OR	A
	JP	Z, L008CH
	DEC	B
	DEC	HL
	;PUSH	HL
	CALL	RST_18
	DB	8, ' ', 8+80h		; см. TZABOJ
	;POP	HL
	JP	L008CH
	endif

BDOSRET:
	LD	HL, (TMPSTK)             ; Точка возврата из функции BDOS
	LD	SP, HL
	LD	L, A
	LD	H, B
	RET

; ──────────────────────────────────────────────
; Инициализация симулятора CP/M
; ВХОД:
;	HL=100H
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ОПИСАНИЕ:
; Перемещает эмулятор BIOS и BDOS в верхние адреса памяти
; Корректирует точку входа в BIOS и BDOS
; ──────────────────────────────────────────────

INIT:
	PUSH	HL
	PUSH	DE
	LD	A, 0C3H
	LD	(0), A
	LD	(5), A
	LD	HL, RAMTOP-100H+3
	LD	(0001H), HL
	LD	HL, RAMTOP-100H
	LD	(0006H), HL
	EX	DE, HL
	LD	HL, BIOSENTRY
	LD	BC, BIOSENTRYEND-BIOSENTRY
	JP	MOVLOO

	ENDIF

; ──────────────────────────────────────────────

TABK2:	DB	09,0AH,0DH,7FH,08H,19H,18H,1AH	; 8 bytes

; ──────────────────────────────────────────────

	END

