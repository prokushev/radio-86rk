;  ══════════════════════════════════════════════════════════════════
;  МОНИТОР РК86 для КР580, VT-52 и симулятором CP/M
;  ══════════════════════════════════════════════════════════════════
;
; Last modify: 13.06.2021
;
;
; IDEAS/QUESTIONS
; ---------------
; 1. Доработать ввод строки до совместимости с CP/M
;
; Звук только на INTE
; В CCP принудительно включается ЛАТ-регистр.
; Удалена директива X. Директива G теперь не имеет второго параметра -
; стоп точки. Зато теперь введён возврат из запуска по G по RET. И можно
; передавать два параметра (второй и третий, они передаются в DE и BC).
;
; Это, если будет место, но мало смысла...
; При запуске директивой G100 включается режим симулятора CP/M.
; При этом формируется нулевая страница. BDOS размещается в адресах
; RAMTOP-100H и занимает 3 байта. BIOS размещается в адресах 
; RAMTOP-100H и занимает 15 байт. Нулевая точка входа в BIOS 
; используется для эмуляции BDOS, т.к. она в никогда не вызывается
; из прикладных программ (как минимум, мне об этом неизвестно)
;
; ВВОД ДИРЕКТИВ И АНАЛИЗ РЕЗУЛЬТАТОВ
; ──────────────────────────────────
;
; После запуска МОНИТОРа экран телевизора очищается, в левом верхнем углу
; появляется надпись <РАДИО-86РК>, а под ней - стрелка -->, уведомляющая
; пользователя о том, что МОНИТОР готов к вводу очередной директивы.
; Неверно набранные символы стирают нажатием на клавишу <ЗБ> (<Забой>).
; <<-> (<Курсор влево>), в отличие от оригинального МОНИТОРа, просто
; смкщает курсор влево. Для выполнения директивы нажимают на клавишу
; возврата каретки "ВК". Если директива задана правильно, то начнется ее
; выполнение, если нет, - на экране появится знак вопроса - признак того,
; что МОНИТОР "не понимает" вашу директиву или произошло переполнение буфера
; ввода.
; 
; Выполнение директив О, L, S может быть прервано. Для этого, удерживая
; клавишу <УС>, надо нажать еще и на <С>; выполнение директивы прервется,
; и МОНИТОР будет готов выполнять следующую.
; 
; Имена всех директив состоят из одной латинской буквы, непосредственно за
; которой могут следовать не более трех параметров, представляющих собой
; шестнадцатеричные числа. Один параметр от другого отделяют запятой или
; пробелом. Их ставят и в тех случаях, когда один из параметров (в том
; числе и первый) отсутствует.
; 
; ДИРЕКТИВЫ РАБОТЫ С ПАМЯТЬЮ
; ──────────────────────────
;
; Содержимое области памяти может быть выведено на экран дисплея либо в
; виде шестнадцатеричных чисел (директива О), либо в виде алфавитно-
; цифровых символов, соответствующих этим кодам (директива L). Если
; при выполнении последней встретятся коды, не соответствующие ни одному
; алфавитно-цифровому символу, то они отобразятся в виде точек. Содержимое
; памяти выводится в виде таблицы из 16 колонок. Слева от каждой строки
; указывается шестнадцатеричный адрес первой в строке ячейки. Форматы
; этих и других директив приведены в табл. 5. Директива М предназначена
; для просмотра и изменения содержимого одной или нескольких ячеек памяти.
; После ее ввода на экране высвечивается адрес ячейки и ее содержимое,
; курсор останавливается справа от этого значения, и МОНИТОР "ожидает"
; ввода с клавиатуры. Если необходимо изменить содержимое ячейки, набирают
; новое значение и нажимают клавишу "ВК", если изменений не требуется, ее
; нажимают сразу же. При каждом нажатии на клавишу "ВК" значение адреса
; автоматически увеличивается на единицу. Выполнение директивы продолжается
; до тех пор, пока не будет нажата клавиша "." (точка).
; 
; Таблица 5
; 
; ДИРЕКТИВЫ МОНИТОРА
; ДИРЕКТИВЫ РАБОТЫ С ПАМЯТЬЮ
; D <НАЧАЛЬНЫЙ АДРЕС>,<КОНЕЧНЫЙ АДРЕC>
; L < НАЧАЛЬНЫЙ АДРЕС>,<КОНЕЧНЫЙ АДРЕС>
; F <НАЧАЛЬНЫЙ АДРЕС >, <КОНЕЧНЫЙ АДРЕС>, <ЗАПИСЫВАЕМЫЙ КОД>
; M <АДРЕС>
; T <НАЧАЛЬНЫЙ АДРЕС>, <КОНЕЧНЫЙ АДРЕС>, <АДРЕС ОБЛАСТИ ПЕРЕСЫЛКИ>
; C <НАЧАЛЬНЫЙ АДРЕС>, <КОНЕЧНЫЙ АДРЕС>, <АДРЕС ОБЛАСТИ СРАВНЕНИЯ>
; S <НАЧАЛЬНЫЙ АДРЕC>, <КОНЕЧНЫЙ АДРЕС>, <ИСКОМЫЙ КОД>
; ДИРЕКТИВЫ ЗАПУСКА И ОТЛАДКИ
; G <АДРЕС ЗАПУСКА>
; ДИРЕКТИВЫ ВВОДА-ВЫВОДА
; O <НАЧАЛЬНЫЙ АДРЕС >,< КОНЕЧНЫЙ АДРЕС>,/<СКОРОСТЬ>/
; I <СМЕЩЕНИЕ >/,/< СКОРОСТЬ>/
; ДОПОЛНИТЕЛЬНЫЕ ДИРЕКТИВЫ
; R <НАЧАЛЬНЫИ АДРЕС ПЗУ>, <КОНЕЧНЫИ АДРЕС ПЗУ>, <АДРЕС ЗАГРУЗКИ>
; (НАКЛОННЫМИ ЧЕРТАМИ ВЫДЕЛЕНЫ НЕОБЯЗАТЕЛЬНЫЕ ПАРАМЕТРЫ)
; Если во все ячейки области памяти необходимо записать одинаковые коды,
; удобно воспользоваться директивой F.
; 
; Директива T предназначена для копирования (пересылки) содержимого одной
; области памяти в другую. Копирование осуществляется побайтно, начиная с
; младшего адреса.
; 
; Для сравнения двух областей памяти необходимо пользоваться директивой C.
; Если содержимое соответствующих ячеек памяти не совпадает, на экран
; выводится адрес ячейки из первой области, ее содержимое и содержимое
; соответствующей ячейки из второй области. МОНИТОР предоставляет
; пользователю возможность поиска кода в заданной области памяти
; (директива S). При обнаружении искомого кода на экране появляются
; адреса ячеек, в которых он был обнаружен.
; 
; ДИРЕКТИВЫ ЗАПУСКА
; ─────────────────
;
; Для запуска программы служит директива G.
; 
; ДИРЕКТИВЫ ВВОДА-ВЫВОДА
; ──────────────────────
;
; Первые два параметра директивы вывода на магнитную ленту О задают
; область памяти, содержимое которой подлежит выводу, третий -
; шестнадцатеричный код, определяющий скорость вывода. Если скорость
; не указать, то будет использовано либо значение, заданное в предыдущей
; директиве вывода, либо стандартное - 1DH (около 1200 бит/с), записываемое
; (при нажатии на кнопку <СБРОС>) в рабочую ячейку МОНИТОРа 03630Н
; (использовать константу вывода менее 10Н недопустимо!). Рекомендуем
; пользоваться стандартной скоростью, так как она выбрана с учетом
; использования магнитофона и магнитной ленты невысокого качества.
; Кроме того, стандартная скорость облегчит обмен программами. После
; завершения вывода, на экране отобразятся начальный и конечный адреса
; и четырехзначная контрольная сумма выведенной информации.
; 
; Ввод с ленты осуществляется по директиве I, которая может иметь два
; параметра. Первым параметром - необязательным - задают смещение. Если
; он есть, вводимая информация будет загружена по адресу, являющемуся
; суммой указанного в записи на ленте адреса и смещения. Второй параметр
; определяет временную задержку при чтении с ленты. Он также может
; отсутствовать, но в этом случае будет взята задержка, использовавшаяся
; в предыдущей команде ввода (если вы не нажимали на кнопку <СБРОС>) или
; установленная (по умолчанию) при начальной настройке рабочих ячеек
; МОНИТОРа (стандартное значение, записанной по адресу 0362FH - 2АН).
; 
; После окончания ввода МОНИТОР сообщит начальный и конечный адреса
; загрузки и контрольную сумму, подсчитанную при вводе информации.
; Если она не совпадет с введенной с ленты, то на следующей строке
; будет выведено значение, записанное на ленте. Этот факт
; свидетельствует об ошибках при чтении информации с ленты.
; 
; Прервать программу ввода с магнитной ленты можно либо выключением
; магнитофона, либо вводом с клавиатуры кода <УС> + <С> (здесь и
; далее латинский регистр).
; 
; Используемый в РК формат записи на магнитную ленту отличается от
; используемого в <Микро-80> только наличием в конце выводимой
; информации контрольной суммы, поэтому программы, записанные с
; <Радио-86РК>, могут быть введены в <Микро-80>. При попытке
; ввести в РК программу, записанную с <Микро-80>, подпрограмма
; ввода будет ожидать ввода контрольной суммы. Если не останавливать
; магнитофон и <позволить> ей читать начало следующей программы, то
; она будет воспринята как контрольная сумма и ввод будет окончен.
; Естественно, что такая <контрольная сумма> не совпадет с реальной,
; и МОНИТОР <ответит> на эти действия вопросительным знаком,
; 
; В табл. 5 приведены форматы еще двух директив: R - чтения
; информации из ПЗУ, подключаемого к ППА D14, и U - предназначенной
; для дальнейшего расширения МОНИТОРа. О них будет рассказано в одном
; из следующих номеров журнала.
;
; СТАНДАРТНЫЕ ПОДПРОГРАММЫ МОНИТОРа
; ─────────────────────────────────
;
;Назначение				Адрес вызова	Параметры
;Ввод символа с клавиатуры		OF803H		ВХОДНЫЕ ВЫХОДНЫЕ
;							А - введенный код
;Ввод байта с магнитофона		0F806Н		ВХОДНЫЕ ВЫХОДНЫЕ
;							А=0FFН с поиском синхробайта
;							A=08Н без поиска синхробайта
;							А - введенный байт
;Вывод символа на экран			0F809Н		ВХОДНЫЕ ВЫХОДНЫЕ
;							С - выводимый символ
;Запись байта на магнитофон		0F80CH		ВХОДНЫЕ ВЫХОДНЫЕ
;							С - выводимый байт
;Опрос состояния клавиатуры		0F812H		ВХОДНЫЕ ВЫХОДНЫЕ
;							A=00H - не нажата
;							A=0FFH - нажата
;Распечатка байта на экране
;в шестнадцатеричном виде		0F15H		ВХОДНЫЕ ВЫХОДНЫЕ
;							А - выводимый код
;Вывод на экран сообщения		0F18H		ВХОДНЫЕ ВЫХОДНЫЕ
;							HL = адрес начала сообщения
;Ввод кода нажатой клавиши		0F1BH		ВХОДНЫЕ ВЫХОДНЫЕ
;							A=0FFH - не нажата
;							A=0FEH - РУС/ЛАТ
;							ИНАЧЕ - код клавиши
;Запрос положения курсора		0F81EH		ВХОДНЫЕ ВЫХОДНЫЕ
;							Н - номер строки
;							L - номер позиции
;Запрос байта из экранного буфера	0F821H		ВХОДНЫЕ ВЫХОДНЫЕ
;							А - код из буфера
;Ввод блока с магнитофона		0F824H		ВХОДНЫЕ ВЫХОДНЫЕ
;							HL - смещение
;							HL - адрес начала
;							DE - адрес конца
;							ВС - контрольная сумма
;Вывод блока на магнитофон		0F27Н		ВХОДНЫЕ
;							ВЫХОДНЫЕ
;							HL - адрес начала
;							DE - адрес конца
;							ВС - контрольная сумма
;Подсчет контрольной суммы блока	0F82AH		ВХОДНЫЕ ВЫХОДНЫЕ
;							HL - адрес начала
;							DE - адрес конца
;							ВС - контрольная сумма
;Запуск индикации на экране		0F82DH		ВХОДНЫЕ выходные
;Передача адреса верхней границы
;свободной памяти программе пользователя	0F830H		ВХОДНЫЕ ВЫХОДНЫЕ
;							HL - адрес границы
;Установка адреса верхней границы
;свободной памяти программы пользователя	0F833H		ВХОДНЫЕ ВЫХОДНЫЕ
;							HL - адрес границы
;
;
; УПРАВЛЯЮЩИЕ КОДЫ ДИСПЛЕЯ
; ────────────────────────
;
; Данная версия МОНИТОРа реализует поддержку управляющих кодов
; дисплея, своместимых с терминалом DECscope VT52. В связи с
; этим, поведение некоторых управляющих кодов отличается от
; оригинальной версии МОНИТОРа.
;
; Управляющие коды, в отличие от остальных, не отображаются в виде
; алфавитно-цифрового или псевдографического символа, а вызывают
; выполнение какой-либо специфичной функции, связанной с управлением
; форматом выводимых на экран сообщений (табл.8).
; 
; Функция <- (<Курсор влево>) вызывает перемещение курсора на одну
; позицию влево. Если курсор находился в самой левой позиции строки,
; то его перемещение, в отличие от оригинального МОНИТОРа, не происходит.
; 
; Функция -> (<Курсор вправо>) перемещает курсор в противоположном
; направлении. Переход курсора на другую стоку, в отличие от оригинального
; МОНИТОРа, не происходит.
; 
; Функции - (<Курсор вверх>) и (<Курсор вниз>) вызывают перемещение
; курсора на одну строку вверх или вниз соответственно. Если при этом
; курсор находился в самой нижней строке экрана, то при выполнении
; функции <Курсор вниз> он, в отличие от оригинального МОНИТОРа,
; останется на той же строке. Аналогично и с функцией <Курсор вверх>.
; 
; Функция <ВК> - <Возврат каретки> (не путать с клавишей) переведет курсор
; в первую позицию той же строки экрана, в которой он и находился. Если
; курсор уже находится в самой левой позиции, его положение не изменится.
; 
; Функция <ПС> (<Перевод строки>) действует так же, как и <Курсор вниз>,
; в том случае, если курсор не находится в последней строке экрана, в
; противном случае курсор остается в прежней позиции, и на экране происходят
; следующие изменения: на месте первой строки появляется вторая, на месте
; второй - третья и т. д., последняя строка экрана очищается. Таким образом,
; текст на экране дисплея передвигается на одну строку вверх, вся информация,
; высвечиваемая в первой строке, теряется, а последняя строка освобождается
; для вывода новой строки символов. Данный процесс называется прокруткой
; экрана.
; 
; Функция <СТР> (<Стирание экрана>) полностью стирает весь текст на экране
; и устанавливает курсор в нулевую позицию (левый верхний угол).
; 
; Функция <\> (<Курсор в начало экрана>) перемещает курсор в левый верхний
; угол экрана. Информация на экране остается неизменной.
; 
; Функция "BEL" выдаст звуковой сигнал продолжительностью примерно 0,25 с.
;
; Функция "TAB" размещает курсор в ближайшей следующей позиции "табулятора".
; Т.е. в позициях 8, 16, 24, 32, 40, 48, 56. Отсчет ведется от 0.
;
; Функция "ESC" переводит в режим обработки Escape-кодов.
;
; Код "A" - Курсор вверх
;
; Код "B" - Курсор вниз
;
; Код "C" - Курсор вправо
;
; Код "D" - Курсор влево
;
; Код "E" - очистка экрана (расширение GDOS/TOS)
;
; Код "F" -- не используется, зарезервирована для включения алтернативного знакогенератора
;
; Код "G" -- не используется, зарезервирована для выключения алтернативного знакогенератора
;
; Код "H" - перемещение курсора в левый верхний угол
;
; Код "I" - обратный перевод строки. Поведение аналогино переводу строки, но прокрутка вверх
;
; Код "J" - очистка до конца экрана
;
; Код "K" - очистка до конца строки
;
; Код "L" - не используется, Insert a line (нет в описании VT-52)
;
; Код "M" - не используется, Remove line (нет в описании VT-52)
;
; Код "Y" - функция прямой адресации курсора. Чтобы установить курсор
; в требуемую позицию на экране, необходимо выдать на дисплей
; последовательность кодов: 1ВН+59Н+(НОМЕР СТРОКИ+20Н)+(НОМЕР ПОЗИЦИИ + 20H).
; Строки и позиции на экране отсчитываются от 0, причем нулевой строкой
; экрана считается самая верхняя строка, а нулевой позицией - самая левая.
;
; Код "Z" - не используется, идентификация типа терминала
;
; Код "[" - не используется, включить удержание экрана
;
; Код "\" - не используется, отключить удержание экрана
;
; Код "=" - не используется, Alternate keypad
;
; Код ">" - не используется, Exit alternate keypad
;
; Код "<" - не используется, включить/выключить поддержку кодов ANSI (VT100)
;
; Код "a" - не используется Скрыть курсор (расширение M/80K)
;
; Код "b" - не используется Показать курсор (расширение M/80K)
;
; Код "b#" - не используется, Foreground color (расширение GDOS/TOS)
;
; Код "c#" - не используется,	Background color (расширение GDOS/TOS)
;
; Код "d" - Очистить экран до левого верхнуго угла экрана (расширение GDOS/TOS)
;
; Код "e" - Показать курсор (расширение GDOS/TOS)
;
; Код "f" - Скрыть курсор (расширение GDOS/TOS)
;
; Код "j" - Запомнить текущую позицию курсора (расширение GDOS/TOS)
;
; Код "k" - Восстановить запомненную позицию курсора (расширение GDOS/TOS)
;
; Код "l" - Очистить текущую строку и установить указатель курсора в начало строки (расширение GDOS/TOS)
;
; Код "o" - Очистить строку от начала строки до текущего положения курсора (расширение GDOS/TOS)
;
; Код "p" - Не используется, Reverse video (расширение GDOS/TOS)
;
; Код "q" - Не используется, Normal video (расширение GDOS/TOS)
;
; Код "v" - Включить автоперенос строки (расширение GDOS/TOS)
;
; Код "w" - Выключить автоперенос строки (расширение GDOS/TOS)
;
	CPU	8080
	Z80SYNTAX	EXCLUSIVE

; ──────────────────────────────────────────────
RABADR	EQU	0F800H
DOPPPA	EQU	0A000H
K_ORIG	EQU	1		; если 0, то измененный курсор
; ──────────────────────────────────────────────

CHK	MACRO	adr, msg
		IF	adr-$
			ERROR	msg
		ENDIF
	ENDM

	ORG	RABADR

BASE    EQU	7600H			; ниже D0H байтов - служебные ячейки

EK_ADR  EQU	BASE			; текущий адрес на экране
POSX	EQU	BASE+02H
POSY	EQU	BASE+03H
ESC_FL	EQU	BASE+04H
KBDFLG	EQU	BASE+05H		; если =0, то есть символ в SYMBUF
RUSLAT	EQU	BASE+06H		; допустимо только 0 или FF  !! Адрес должен быть xx06h иначе править SET_RL !!
LAST_K	EQU	BASE+09H		; эти 2 байта должны следовать подряд
COUNT	EQU	BASE+0AH		; счётчик опросов (вначале 15)
APVFLG	EQU	BASE+0BH		; флаг автоповтора
FRELOC	EQU	BASE+0CH		; эта ячейка не используется

TMPSTK	EQU	BASE+0DH		; временно храним стек при МГ п/п-ммах
POINT	EQU	BASE+14H		; адрес откуда произошёл RST_30H
XYSTOR	EQU	POINT			; Сохраненные координаты курсора
R_HL	EQU	BASE+16H
SASTOR	EQU	R_HL			; Сохраненный адрес курсора
R_BC	EQU	BASE+18H
CURST	EQU	R_BC			; Отображать/прятать курсор
WRPFLG	EQU	R_BC+1			; Автоперенос строк
R_SP	EQU	BASE+1CH
RAMTOP	EQU	R_SP			;
R_AF	EQU	BASE+1EH		; ниже откладываются AF,HL,DE,BC (в этой версии не используется)
STOP_A  EQU	BASE+23H
TMP_COD EQU	BASE+25H
P_JMP	EQU	BASE+26H		; для байта C3H (JMP)
KNS_WR	EQU	P_JMP
PAR_HL  EQU	BASE+27H
PAR_DE  EQU	BASE+29H
PAR_BC  EQU	BASE+2BH
FLG_P2	EQU	BASE+2DH		; флаг, что есть параметры 2 или 2,3
INV_MG	EQU	BASE+2EH
KNS_RD	EQU	BASE+2FH
;KNS_WR	EQU	BASE+30H
;RAMTOP	EQU	BASE+31H
BUFSIZ	EQU	BASE+30H
BUFCNT	EQU	BASE+31H
COMBUF	EQU	BASE+33H		; буфер ввода директивы
STACK	EQU	BASE+0D0H		; стек монитора

MARGIN_TOP	EQU	3
MARGIN_BOTTOM	EQU	3		;?
MARGIN_LEFT	EQU	8
MARGIN_RIGHT	EQU	8		;?

SA	EQU	BASE+0D0H		; 76D0 начало экранной области
SCBASE  EQU	BASE+01C2H		; 77C2 ЛЕВ.ВЕРХН.УГОЛ ЭКР.

VG_75   EQU	0C000H
VT_57   EQU	0E000H

PA	EQU	8000H
PB	EQU	PA+1
PC	EQU	PA+2
PU	EQU	PA+3

PDA	EQU	DOPPPA
PDB	EQU	PDA+1
PDC	EQU	PDA+2
PDU	EQU	PDA+3

; ──────────────────────────────────────────────

LOOP	MACRO	ADDR
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,ADDR
	ENDM

; ──────────────────────────────────────────────
; Блок векторов МОНИТОРа
; ──────────────────────────────────────────────

	JP	ColdBoot		; +0
	JP	InputSymbol 		; +3
	JP	TapeReadByte		; +6
	JP	PrintCharFromC		; +9
	JP	TapeWriteByte		; +C
	JP	PrintCharFromC		; +F   это д.быть PRINT
	JP	GetKeyboardStatus	; +12
	JP	PrintHexByte 		; +15
	JP	PrintString  		; +18
	JP	ReadKeyCode 		; +1B
	JP	GetCursorPos		; +1E
	JP	ReadVideoRAM		; +21
	JP	TapeReadBlock		; +24
	JP	TapeWriteBlock		; +27
	JP	CalcChecksum		; +2A
	JP	InitVideo		; +2D
	JP	GetFreeMemAddr		; +30
	JP	SetFreeMemAddr		; +33
	JP	READARAM		; +36
	JP	WRITEARAM		; +39
	JP	SetCursorPos		; +3C
	RET				; +3F
Version:
	;DB	"V3.xx"

; ──────────────────────────────────────────────
; Первичная инициализация МОНИТОРа
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Не определено
; ──────────────────────────────────────────────

ColdBoot:
	LD	HL,BASE-1
	LD	(RAMTOP),HL
	LD	SP,HL

	LD	A,8AH
	LD	(PU),A

	INC	HL			; LD HL,BASE
	LD	C,L			; 0
	LD	DE,COMBUF+2CH
	CALL	DirectiveFill

	XOR	A
	LD	(WRPFLG), A

	LD	A, 0A9H
	LD	(CURST), A
	CALL	InitVideo

	CALL	RST_18
	DB	1Fh,"8",'6' + 80H

	LD	HL,1D2AH
	LD	(KNS_RD),HL

; ──────────────────────────────────────────────
; "Теплый" старт МОНИТОРа
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Не определено
; ──────────────────────────────────────────────

	CHK	0f86ch, "* Standard subroutine WarmBoot shifted ! *"

WarmBoot:
	LD	SP,STACK

	LD	A,90H
	LD	(PDU),A

	CALL	RST_18
	DB	13,10,'>'+128

	CALL	InputDirective

	LD	HL,WarmBoot
	PUSH	HL


	CALL	GETPRM
	LD	HL,COMBUF
	LD	A,(HL)
	LD	HL,(PAR_BC)		; Z80: LD BC,(PAR_BC)
	LD	C,L
	LD	B,H
	LD	HL,(PAR_DE)		; Z80: LD DE,(PAR_DE)
	EX	DE,HL

	LD	HL, DIRTABLE-1
DIRLOOP:
	INC	HL
	CP	(HL)
	PUSH	AF
	XOR	A
	CP	(HL)
	JP	Z,SyntaxError
	POP	AF
	JP	NZ, DIRLOOP
	INC	HL
	LD	L, (HL)
	PUSH	HL
	LD	HL,(PAR_HL)
	RET

; ──────────────────────────────────────────────

AFE97:	PUSH	HL			; 27 bytes
	LD	HL,7 << 8 + 1
AFE9C:	LD	A,L
	RRCA
	LD	L,A
	CPL
	LD	(PA),A
	LD	A,(PB)
	CPL
	OR	A
	JP	NZ,AFEB3
	DEC	H
	JP	P,AFE9C
AFEAF:	LD	A,0FFH
	POP	HL
	RET

; ──────────────────────────────────────────────
; Возврат каретки
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
; 	HL, BC, AF
; ОПИСАНИЕ:
;	Курсор перемещается в начало текущей строки.
; ──────────────────────────────────────────────

COD_0D:	LD	A,L		; 13 bytes
	SUB	E
	JP	NC,AFDF9
	DEC	H
AFDF9:	LD	L,A
	LD	BC,8
	LD	E,C
	ADD	HL,BC
	RET

; ──────────────────────────────────────────────
; Загрузка BC с поиском синхробайта
; ВХОД:
;	Нет
; ВЫХОД:
;	BC	- загруженные байта
; ИЗМЕНЯЕТ:
;	AF, BC
; ──────────────────────────────────────────────

TapeReadWordSync:
	LD	A, 0FFH			; 14 bytes
	DB	1			; LD BC, ..

; ──────────────────────────────────────────────
; Загрузка BC без поиска синхробайта
; ВХОД:
;	Нет
; ВЫХОД:
;	BC	- загруженные байта
; ИЗМЕНЯЕТ:
;	AF, BC
; ──────────────────────────────────────────────

TapeReadWordNoSync:
	LD	A, 8

; ──────────────────────────────────────────────
; Загрузка слова в BC
; ВХОД:
;	A=008H	- без поиска синхробайта
;	A=0FFH	- с поиском синхробайта
; ВЫХОД:
;	BC	- загруженные байта
; ИЗМЕНЯЕТ:
;	AF, BC
; ──────────────────────────────────────────────

TapeReadWord:
	CALL	TapeReadByte
	LD	B, A
	CALL	TapeReadByteNoSync
	LD	C, A
	RET

; ──────────────────────────────────────────────
; Печать строки по адресу DE
; ВХОД:
;	DE	- адрес строки. $ - признак конца
;		  или символ больше 7Fh
; ВЫХОД:
;	HL	- адрес последнего напечатанного символа
; ИЗМЕНЯЕТ:
;	AF, B, HL, DE
; ──────────────────────────────────────────────

MSGCPM:	EX	DE, HL
	LD	B, '$'
	DB	11h			; LD DE, ...

; ──────────────────────────────────────────────
; Печать строки по адресу HL
; ВХОД:
;	HL	- адрес строки. 0H - признак конца
;		  или символ больше 7Fh
; ВЫХОД:
;	HL	- адрес последнего напечатанного символа
; ИЗМЕНЯЕТ:
;	AF, B, HL
; ──────────────────────────────────────────────

PrintString:
	LD	B, 0			; 13 bytes
	LD	A,(HL)
	CP	B			; CP 0
	RET	Z
	CALL	PrintCharFromA
	INC	HL
	RET	M			; RET if high bit set
	JP	PrintString

; ──────────────────────────────────────────────
; Ввод строки в буфер COMBUF
; ВХОД:
;	Нет
; ВЫХОД:
;	COMBUF	- введенная строка
; ИЗМЕНЯЕТ:
;	AF, DE, HL, BC
; ──────────────────────────────────────────────

	CHK	0F8EEH, "* Internal subroutine InputDirective shifted ! *"

InputDirective:
	LD	DE,COMBUF

; ──────────────────────────────────────────────
; Ввод строки в буфер DE (CP/M совместимо)
; ВХОД:
;	DE	- адрес буфера
; ВЫХОД:
;	COMBUF	- введенная строка
; ИЗМЕНЯЕТ:
;	AF, DE, HL, BC
; ──────────────────────────────────────────────

GETLIN2:
	EX	DE, HL
	LD	D,H
	LD	E,L
GotoCmdLineBegin:
	XOR	A
	LD	B,A			; чтобы на выходе получить флаг пустой строки
	CALL	SET_RL			; Включить латинский регистр
InputNextSymbol:
	CALL	InputSymbol		; используется в DirectiveModify
	CP	7FH
	JP	Z,ProcessBackspace
	LD	(HL),A
	CALL	PrintCharFromA
	CP	13
	JP	Z,AF91A
	CP	'.'
	JP	Z,WarmBoot
	LD	B,E			; B=76H --> бит D7=0
	LD	A, (COMBUF & 00FFh)+31
	CP	L
	JP	Z,SyntaxError
	INC	HL
	LD	(BUFCNT), HL
	JP	InputNextSymbol

; ──────────────────────────────────────────────

AF91A:	SUB	B			; 2 bytes
	RET

; ──────────────────────────────────────────────

	ORG	0f92ch

; ──────────────────────────────────────────────
; Читает аргументы со второй позиции буфера команды в регистры HL, DE, BC
; Разделителями считаются ',' и ' '. Конец данных - CR
; ВХОД:
;	Нет
; ВЫХОД:
;	HL	- первый аргумент
;	DE	- первый аргумент, если один параметр в строке, иначе второй аргумент
;	BC	- третий аргумент
;	При ошибке разбора выходит в МОНИТОР
; ИЗМЕНЯЕТ:
;	AF, HL, DE, BC
; ──────────────────────────────────────────────

	CHK	0F92cH, "* Internal subroutine GETPRM shifted ! *"

GETPRM:	LD	HL,PAR_HL	; Обнуляем параметры
	LD	DE,FLG_P2
	LD	C,0
	CALL	DirectiveFill

;if	high (BASE+34H) eq high BASE
	LD	E,34H
;    else
;	.printx *      Wrong BASE (Low BASE need be < 0E0H) !
;endif
	CALL	GET_HL
	LD	(PAR_HL),HL
	LD	(PAR_DE),HL
	RET	C
	LD	(FLG_P2),A

	CALL	GET_HL
	LD	(PAR_DE),HL
	RET	C

	CALL	GET_HL
	LD	(PAR_BC),HL
	RET	C
	JP	SyntaxError

; ──────────────────────────────────────────────
; Заполняет память с HL по DE байтом C
; ВХОД:
;	HL	- начальный адрес
;	DE	- конечный адрес
;	C	- байт для записи
; ВЫХОД:
;	HL	- конечный адрес
; ИЗМЕНЯЕТ:
;	AF, HL
; ──────────────────────────────────────────────

DirectiveFill:					; 7 bytes
	LD	(HL),C
	CALL	IncHLAndRetIfEqDE
	JP	DirectiveFill

; ──────────────────────────────────────────────
; Выполняет переход по адресу HL
; ВХОД:
;	HL	- адрес
; ВЫХОД:
;	НЕт
; ИЗМЕНЯЕТ:
;	Не определено
; ОПИСАНИЕ:
;	В стеке содержится адрес WarmBoot
; ──────────────────────────────────────────────

DirectiveGoto:
	IF	(DirectiveGoto & 0FF00H) <> (DirectiveFill & 0FF00H)
		ERROR	"DirectiveGoto and DirectiveFill must be in same page"
	ENDIF
;	PUSH	DE
;	LD	DE, 0100H
;	CALL	Compare_HL_DE
;	CALL	Z, INIT
;	POP	DE
	JP	(HL)			; 1 bytes

; ──────────────────────────────────────────────
; Перемещает область памяти с HL по DE в адреса BC
; ВХОД:
;	HL	- начальный адрес
;	DE	- конечный адрес
;	BC	- целевой адрес
; ВЫХОД:
;	HL	- конечный адрес источника
;	BC	- целевой конечный адрес
; ИЗМЕНЯЕТ:
;	AF, HL, BC
; ──────────────────────────────────────────────

DirectiveTransfer:
	IF	(DirectiveGoto & 0FF00H) <> (DirectiveTransfer & 0FF00H)
		ERROR	"DirectiveGoto and DirectiveTransfer must be in same page"
	ENDIF
	LD	A,(HL)			; 9 bytes
	LD	(BC),A
	INC	BC
	CALL	IncHLAndRetIfEqDE
	JP	DirectiveTransfer

; ──────────────────────────────────────────────

DirectiveInputTape:
	IF	(DirectiveInputTape & 0FF00H) <> (DirectiveTransfer & 0FF00H)
		ERROR	"DirectiveInputTape and DirectiveTransfer must be in same page"
	ENDIF
	LD	A,(FLG_P2)		; 46 bytes
	OR	A
	JP	Z,AFA91
	LD	A,E
	LD	(KNS_RD),A
AFA91:	CALL	TapeReadBlock

	CALL	PrintCRAndHexWordAndSpaceAndCRAndHexWordAndSpace
	EX	DE,HL

	PUSH	BC
	CALL	CalcChecksum
	CALL	PrintCRAndHexWordBCAndSpace
	POP	DE

	CALL	Compare_HL_DE
	RET	Z
	CALL	PrintCRAndHexWordDEAndSpace
SyntaxError:
	CALL	RST_18
	DB	'?'+80H
	JP	WarmBoot

; ──────────────────────────────────────────────
; Сравнение значений HL и DE
; ВХОД:
;	HL	- первые число
;	DE	- второе число
; ВЫХОД:
;	Z	- числа совпадают
;	NZ	- числа не совпадают
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

	CHK	0F990H, "* Internal subroutine Compare_HL_DE shifted ! *"

Compare_HL_DE:
	LD	A,H
	CP	D
	RET	NZ
	LD	A,L
	CP	E
	RET

; ──────────────────────────────────────────────
; Считывает область памяти ROM-диска с HL по DE в адреса BC ОЗУ
; ВХОД:
;	HL	- начальный адрес
;	DE	- конечный адрес
;	BC	- целевой адрес
; ВЫХОД:
;	HL	- конечный адрес источника
;	BC	- целевой конечный адрес
; ИЗМЕНЯЕТ:
;	AF, HL, BC
; ──────────────────────────────────────────────

DirectiveReadROM:					; 19 bytes
	IF	(DirectiveInputTape & 0FF00H) <> (DirectiveReadROM & 0FF00H)
		ERROR	"DirectiveInputTape and DirectiveReadROM must be in same page"
	ENDIF
	LD	(PDB),HL
	LD	A,(PDA)
	LD	(BC),A
	INC	BC
	CALL	IncHLAndRetIfEqDE
	JP	DirectiveReadROM

; ──────────────────────────────────────────────
; Ищет байт C в области памяти с HL по DE
; ВХОД:
;	HL	- начальный адрес
;	DE	- конечный адрес
;	C	- искомый байт
; ВЫХОД:
;	HL	- конечный адрес источника
; ИЗМЕНЯЕТ:
;	AF, HL
; ──────────────────────────────────────────────

DirectiveSearch:
	IF	(DirectiveSearch & 0FF00H) <> (DirectiveReadROM & 0FF00H)
		ERROR	"DirectiveReadROM and DirectiveSearch must be in same page"
	ENDIF
	LD	A,C			; 11 bytes
	CP	(HL)
	CALL	Z,PrintCRAndHexWordAndSpace
	CALL	IncHLAndRetIfEqDEWithBrk
	JP	DirectiveSearch

	NOP
; ──────────────────────────────────────────────

	CHK	0F9B0H, "* Internal subroutine CR shifted ! *"

CR:	CALL	RST_18
	DB	13,10 + 80H
	RET

; ──────────────────────────────────────────────
; Дамп области памяти с HL по DE
; ВХОД:
;	HL	- начальный адрес
;	DE	- конечный адрес
; ВЫХОД:
;	HL	- конечный адрес источника
; ИЗМЕНЯЕТ:
;	AF, HL		!!TODO!! проверить подпрограммы на изменение
; ──────────────────────────────────────────────

DirectiveDump:
	IF	(DirectiveSearch & 0FF00H) <> (DirectiveDump & 0FF00H)
		ERROR	"DirectiveDump and DirectiveSearch must be in same page"
	ENDIF
	CALL	PrintCRAndHexWordAndSpace			; 18 bytes
AF9C8:	CALL	PrintHexByteFromMemAndSpace
	CALL	IncHLAndRetIfEqDEWithBrk
	LD	A,L
	AND	0FH
	JP	Z,DirectiveDump
	JP	AF9C8


; ──────────────────────────────────────────────
DIRTABLE:				; 23 bytes
	IF	(DIRTABLE & 0FF00H) <> (DirectiveDump & 0FF00H)
		ERROR	"DirectiveDump and DIRTABLE must be in same page"
	ENDIF

	DB	'C', DirectiveCompare & 0FFH
	DB	'D', DirectiveDump & 0FFH
	DB	'F', DirectiveFill & 0FFH
	DB	'G', DirectiveGoto & 0FFH
	DB	'I', DirectiveInputTape & 0FFH
	DB	'L', DirectiveList & 0FFH
	DB	'M', DirectiveModify & 0FFH
	DB	'O', DirectiveOutputTape & 0FFH
	DB	'R', DirectiveReadROM & 0FFH
	DB	'S', DirectiveSearch & 0FFH
	DB	'T', DirectiveTransfer & 0FFH
	DB	0


DirectiveModify:

	IF	(DIRTABLE & 0FF00H) <> (DirectiveModify & 0FF00H)
		ERROR	"DirectiveModify and DIRTABLE must be in same page"
	ENDIF

	CALL	PrintCRAndHexWordAndSpaceAndHexByteMemAndSpace			; 22 bytes
	PUSH	HL
	CALL	InputDirective
	POP	HL
	JP	NC,AFA3B
	PUSH	HL
	CALL	GET_HL
	LD	A,L
	POP	HL
	LD	(HL),A
AFA3B:	INC	HL
	JP	DirectiveModify

; ──────────────────────────────────────────────

DirectiveOutputTape:

	IF	(DIRTABLE & 0FF00H) <> (DirectiveOutputTape & 0FF00H)
		ERROR	"DirectiveOutputTape and DIRTABLE must be in same page"
	ENDIF

	JP	DirectiveOutputTape_2

DirectiveCompare:
	IF	(DirectiveCompare & 0FF00H) <> (DirectiveFill & 0FF00H)
		ERROR	"DirectiveCompare and DirectiveFill must be in same page"
	ENDIF

	JP	DirectiveCompare_2

; ──────────────────────────────────────────────
; Вывод текста области памяти с HL по DE
; ВХОД:
;	HL	- начальный адрес
;	DE	- конечный адрес
; ВЫХОД:
;	HL	- конечный адрес источника
; ИЗМЕНЯЕТ:
;	AF, HL		!!TODO!! проверить подпрограммы на изменение
; ──────────────────────────────────────────────

DirectiveList:

	IF	(DIRTABLE & 0FF00H) <> (DirectiveList & 0FF00H)
		ERROR	"DirectiveList and DIRTABLE must be in same page"
	ENDIF

	CALL	PrintCRAndHexWordAndSpace			; 30 bytes
AFA0B:	LD	A,(HL)
	OR	A
	JP	M,AFA15
	CP	20H
	JP	NC,AFA17
AFA15:	LD	A,'.'
AFA17:	CALL	PrintCharFromA
	CALL	IncHLAndRetIfEqDEWithBrk
	LD	A,L
	AND	0FH
	JP	Z,DirectiveList
	JP	AFA0B

; ──────────────────────────────────────────────

DirectiveOutputTape_2:
	LD	A,C
	OR	A
	JP	Z,AFB35
	LD	(KNS_WR),A
AFB35:	PUSH	HL
	CALL	CalcChecksum
	POP	HL
	
	CALL	PrintCRAndHexWordAndSpaceAndCRAndHexWordAndSpace
	EX	DE,HL
	
	PUSH	HL
	CALL	PrintCRAndHexWordBCAndSpace
	POP	HL

TapeWriteBlock:
	PUSH	BC		; КС

	LD	BC,0		; выводим 256 байтов 00 (пилотон)
AFB4D:	CALL	TapeWriteByte
	EX	(SP),HL 	; это задержка 38 тактов
	EX	(SP),HL
	DEC	B
	JP	NZ,AFB4D

	CALL	TapeWriteSync

	CALL	TapeWriteWord		; выводим НА
	EX	DE,HL
	CALL	TapeWriteWord		; выводим КА

	EX	DE,HL
	CALL	TapeWriteFromHLtoDE		; выводим блок

	LD	HL,0
	CALL	TapeWriteWord		; выводим 2 байта 00

	CALL	TapeWriteSync

	POP	HL
	CALL	TapeWriteWord		; выводим КС

	JP	InitVideo

; ──────────────────────────────────────────────

AFF3B:	LD	A,L			; 23 bytes
	AND	2FH
	LD	L,A
AFF3F:	LD	A,L
	CP	40H
	POP	HL
	RET	P
	PUSH	HL
	LD	L,A
	AND	00FH
	CP	00CH
	LD	A,L
	JP	M,AFF50
	XOR	10H
AFF50:	POP	HL
	RET

; ──────────────────────────────────────────────
; Расчет контрольной суммы блока памяти с HL по DE
; ВХОД:
;	HL	- начальный адрес
;	DE	- конечный адрес
; ВЫХОД:
;	HL	- конечный адрес источника
;	BC	- контрольная сумма
; ИЗМЕНЯЕТ:
;	AF, BC, HL
; ──────────────────────────────────────────────

CalcChecksum:
	LD	BC,0			; 23 bytes
AFB19:	LD	A,(HL)
	ADD	A,C
	LD	C,A
	PUSH	AF
	CALL	Compare_HL_DE
	JP	Z,POPAF
	POP	AF
	LD	A,B
	ADC	A,(HL)
	LD	B,A
	CALL	IncHLAndRetIfEqDE
	JP	AFB19

; ──────────────────────────────────────────────

KEY_FE:	LD	A,(PC)			; 17 bytes
	RLA
	JP	NC,KEY_FE		; ждём отпускания РУС/ЛАТ
	LD	A,(RUSLAT)
	CPL
	CALL	SET_RL
	JP	AFE1A

; ──────────────────────────────────────────────

BYTE3:	LD	A,C			; 18 bytes
	SUB	20H
	LD	C,A
AFD77:	DEC	C
	LD	A,3
	JP	M,SETESC
	PUSH	BC
	CALL	CursorDown
	POP	BC
	JP	AFD77

; ──────────────────────────────────────────────

RST_18:	EX	(SP),HL			; 6 bytes
	CALL	PrintString
	EX	(SP),HL
	RET

	NOP
	NOP
	NOP
	NOP
	NOP
	
; ──────────────────────────────────────────────

TapeReadBlock:
	CALL	TapeReadWordSync
	PUSH	HL
	ADD	HL,BC
	EX	DE,HL
	CALL	TapeReadWordNoSync
	POP	HL
	ADD	HL,BC
	EX	DE,HL
	PUSH	HL
	CALL	LD_BLK
	CALL	TapeReadWordSync		; с поиском СБ
	POP	HL
	DB	06h		; LD B, ..

	IF	(RUSLAT & 0FFH) <> 6
		ERROR	"RUSLAT low byte must be 06h"
	ENDIF
SET_RL:	LD	(RUSLAT),A		; Т.к. адрес RUSLAT xx06h, то предыдущий трюк с LD B, .. повторится..

; ──────────────────────────────────────────────

	CHK	0FACEH, "* Internal subroutine InitVideo shifted ! *"
InitVideo:			; 1001.0011
				; 1100.0011

	LD	A, (CURST)	; 99H - включен A9H выключен

	PUSH	HL
	LD	HL,VG_75+1
	LD	(HL),0   	; reset commando
	DEC	HL       	; адрес VG_75
	LD	(HL),04DH	; 0.1001101  77+1 знакомест
	LD	(HL),01DH	; 00.011101  29+1 строк

	LD	(HL),A		; 1001.1001  9 +1 линия подчерк.
				; 9+1 линий в знакоместе
	if	K_ORIG
	LD	(HL),93H
	else
	LD	(HL),0C3H
	endif

	INC	HL		; адрес VG_75+1
	LD	(HL),27H	; start display commando
	LD	A,(HL)		; read status
AFAE1:	LD	A,(HL)		; read status
	AND	20H		; mask 'Interrupt request flag'
	JP	Z,AFAE1		; ждем конца строки
	LD	HL,VT_57+8
	LD	(HL),80H
	LD	L,4		; VT_57+04
	LD	(HL),SA & 00FFh 	; 0D0H
	LD	(HL),SA>>8	; 076H
	INC	L		; адрес VT_57+5
	LD	(HL),23H
	LD	(HL),49H
	LD	L,8		; VT_57+8
	LD	(HL),0A4H
	POP	HL
	RET

; ──────────────────────────────────────────────────────
; Вводит в HL HEX-число из строки по (DE) до нажатия ВК
; ──────────────────────────────────────────────────────

GET_HL:	LD	HL,0		; 48 bytes
AF95D:	LD	A,(DE)		; Выход: CY=1 если разделитель <ВК>
	INC	DE
	CP	13
	SCF
	RET	Z
	CP	','
	RET	Z
	CP	20H
	JP	Z,AF95D

	LD	BC,SyntaxError
	PUSH	BC

	SUB	'0'
	RET	C		; JP C,SyntaxError

	CP	9+1
	JP	C,AF982

	CP	'A'-'0'
	RET	C		; JP C,SyntaxError

	CP	'F'-'0'+1
	RET	NC		; JP NC,SyntaxError

	SUB	'A'-('9'+1)
AF982:
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	RET	C		; JP C,SyntaxError

	OR	L
	LD	L,A

	POP	AF
	JP	AF95D

; ──────────────────────────────────────────────

NO_ESC:	LD	A,C
	AND	7FH
	LD	C,A
	SUB	1FH		;CP	1FH
	JP	Z, ClearScreen
	ADD	A, 4		;CP	1BH
	JP	Z,EscapeHandlerStart
	INC	A		;CP	1AH
	JP	Z,CursorDown
	INC	A		;CP	19H
	JP	Z,CursorUp
	INC	A		;CP	18H
	JP	Z,CursorRight
	ADD	A, 18H-0DH	;CP	0DH
	JP	Z,COD_0D
	INC	A		;CP	0CH
	JP	Z,CursorHome
	ADD	A, 0CH-0AH	;CP	0AH
	JP	Z,LF
	INC	A		;CP	09H
	JP	NZ,skip_TAB

; ──────────────────────────────────────────────

TAB:	LD	D, 0
	CALL	SUBHLDE
	ADD	A, E
	ADD	A, 8
	AND	11111000b
	LD	D, 0
	LD	E, A
	ADD	HL, DE
	RET

; ──────────────────────────────────────────────

TABK2:	DB	09,0AH,0DH,7FH,08H,19H,18H,1AH	; 8 bytes

; ──────────────────────────────────────────────
; Печать перевода строки, числа из HL в 16-ричном формате, пробела,
; перевода строки, числа из BC в 16-ричном формате, пробела
; ВХОД:
;	HL	- число для печати
;	BC	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B, DE, HL
; ──────────────────────────────────────────────

PrintCRAndHexWordAndSpaceAndCRAndHexWordAndSpace:	CALL	PrintCRAndHexWordAndSpace

; ──────────────────────────────────────────────
; Печать перевода строки, числа из BC в 16-ричном формате и пробела
; ВХОД:
;	BC	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B, DE, HL
; ──────────────────────────────────────────────

PrintCRAndHexWordBCAndSpace:
	LD	D,B
	LD	E,C

; ──────────────────────────────────────────────
; Печать перевода строки, числа из DE в 16-ричном формате и пробела
; ВХОД:
;	DE	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B, DE, HL
; ──────────────────────────────────────────────

PrintCRAndHexWordDEAndSpace:
	EX	DE,HL

; ──────────────────────────────────────────────
; Печать перевода строки, числа из HL в 16-ричном формате и пробела
; ВХОД:
;	HL	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B
; ──────────────────────────────────────────────

	CHK	0FB78H, "* Internal subroutine PrintCRAndHexWordAndSpace shifted ! *"

PrintCRAndHexWordAndSpace:
	CALL	CR

; ──────────────────────────────────────────────
; Печать числа из HL в 16-ричном формате и пробела
; ВХОД:
;	HL	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

PrintHexWordAndSpace:
	LD	A,H
	CALL	PrintHexByte
	LD	A,L
	JP	PrintHexByteAndSpace

; ──────────────────────────────────────────────

AFEF3:	LD	A,H			; 7 bytes
	LD	HL,TABK1
	JP	AFEFE

; ──────────────────────────────────────────────
; Возвращает в HL координаты курсора
; ВХОД:
;	Нет
; ВЫХОД:
;	H - Y
;	L - X
; ИЗМЕНЯЕТ:
;	HL
; ──────────────────────────────────────────────

GetCursorPos:
	LD	HL,(POSX)		; 4 bytes
	RET

; ──────────────────────────────────────────────

DirectiveCompare_2:
	LD	A,(BC)			; 19 bytes
	CP	(HL)
	JP	Z,AF9E6
	CALL	PrintCRAndHexWordAndSpaceAndHexByteMemAndSpace
	LD	A,(BC)
	CALL	PrintHexByteAndSpace
AF9E6:	INC	BC
	CALL	IncHLAndRetIfEqDEWithBrk
	JP	DirectiveCompare_2


; ──────────────────────────────────────────────
; Загрузка A без поиска синхробайта
; ВХОД:
;	Нет
; ВЫХОД:
;	A	- загруженный байт
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

TapeReadByteNoSync:
	LD	A,8

; ──────────────────────────────────────────────
; Загрузка A
; ВХОД:
;	A=008H	- без поиска синхробайта
;	A=0FFH	- с поиском синхробайта
; ВЫХОД:
;	A	- загруженный байт
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

TapeReadByte:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	D,A
AFB9C:	LD	A,80H
	LD	(VT_57+8),A

	LD	HL,0
	LD	C,L
	ADD	HL,SP
	LD	(TMPSTK),HL

	LD	SP,0
	LD	A,(PC)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	1
	LD	E,A
AFBB7:	POP	AF
	LD	A,C
	AND	07FH
	RLCA
	LD	C,A
	LD	H,0
AFBBF:	DEC	H
	JP	Z,AFC34
	POP	AF		; Регенерация ОЗУ
	LD	A,(PC)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	1
	CP	E
	JP	Z,AFBBF
	OR	C
	LD	C,A
	DEC	D
	LD	A,(KNS_RD)
	JP	NZ,AFBDC
	SUB	012H
AFBDC:	LD	B,A
AFBDD:	POP	AF		; Регенерация ОЗУ
	DEC	B
	JP	NZ,AFBDD
	INC	D
	LD	A,(PC)
	RRCA
	RRCA
	RRCA
	RRCA
	AND	001H
	LD	E,A
	LD	A,D
	OR	A
	JP	P,AFC0B
	LD	A,C
	CP	0E6H		; ПРЯМОЙ СИНХРО-БАЙТ ?
	JP	NZ,AFBFF
	XOR	A
	LD	(INV_MG),A	; ПРИЗНАК ИНВЕРСИИ МАГНИТОФОНА
	JP	AFC09

; ──────────────────────────────────────────────

AFBFF:	CP	19H		; ОБРАТНЫЙ С/БАЙТ
	JP	NZ,AFBB7	; 58 bytes
	LD	A,0FFH
	LD	(INV_MG),A 	; Tape inverse flag
AFC09:	LD	D,9
AFC0B:	DEC	D
	JP	NZ,AFBB7

	LD	HL,VT_57+4
	LD	(HL), SA & 00FFH		; 0D0H
	LD	(HL), SA >>8		; 076H
	INC	HL
	LD	(HL),023H
	LD	(HL),049H
	LD	A,27H			; start display commando
	LD	(VG_75+1),A
	LD	A,0E0H			; reset count
	LD	(VG_75+1),A
	LD	L,8
	LD	(HL),0A4H

	LD	HL,(TMPSTK)
	LD	SP,HL

	LD	A,(INV_MG)
	XOR	C			; with Tape Inverse flag
	JP	POPREG

; ──────────────────────────────────────────────
; Запись слова
; ВХОД:
;	HL	- слово для записи
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	BC
; ──────────────────────────────────────────────

TapeWriteWord:
	LD	C,H
	CALL	TapeWriteByte
	LD	C,L
	DB	06H		; LD B,..

; ──────────────────────────────────────────────
; Запись синхробайта
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	C
; ──────────────────────────────────────────────

TapeWriteSync:
	LD	C, 0E6H

; ──────────────────────────────────────────────
; Запись байта C
; ВХОД:
;	C	- байт для записи
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

TapeWriteByte:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	AF
	LD	A,80H
	LD	(VT_57+8),A
	LD	HL,0
	ADD	HL,SP		; временно храним стек
	LD	SP,0		; для регенерации
	LD	D,8
AFC58:	POP	AF
	LD	A,C
	RLCA
	LD	C,A
	LD	A,1
	XOR	C
	LD	(PC),A
	LD	A,(KNS_WR)
	LD	B,A
AFC66:	POP	AF
	DEC	B
	JP	NZ,AFC66
	XOR	A
	XOR	C
	LD	(PC),A
	DEC	D
	LD	A,(KNS_WR)
	JP	NZ,AFC7A
	SUB	14
AFC7A:	LD	B,A

AFC7B:	POP	AF		; подъем стека на [рег.B] ячеек
	DEC	B
	JP	NZ,AFC7B
	INC	D
	DEC	D
	JP	NZ,AFC58

	LD	SP,HL
	LD	HL,VT_57+4
	LD	(HL), SA & 00FFh	; 0D0H
	LD	(HL), SA >> 8	; 076H
	INC	HL		; VT_57+5
	LD	(HL),23H
	LD	(HL),49H
	LD	A,27H		; start display commando
	LD	(VG_75+1),A	; 001.sss.bb    001.001.11
	LD	A,0E0H		; сброс счетчиков строк и знакомест ???
	LD	(VG_75+1),A
	LD	L,8
	LD	(HL),0A4H	; VT_57+8
POPREGA:
	POP	AF
POPREG: POP	HL
	POP	DE
	POP	BC
	RET

; ──────────────────────────────────────────────
; Печать числа из A в 16-ричном формате
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

PrintHexByte:
	PUSH	AF			; 23 bytes
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	PrintHexNibble
	POP	AF

; ──────────────────────────────────────────────
; Печать числа из младшего нибла A в 16-ричном формате
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

PrintHexNibble:
	AND	0FH
	CP	10
	SBC	A,2FH
	DAA

; ──────────────────────────────────────────────
; Печать символа из A
; ВХОД:
;	A	- символ для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

PrintCharFromA:
	PUSH	BC		; 10 bytes
	LD	C,A
	DB	06h		; LD B,..

; ──────────────────────────────────────────────
; Печать символа из C
; ВХОД:
;	C	- символ для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

;BUG Для эмуляции VT-52 необходимо игнорировать код NUL (00H) и DEL (7FH). С последним проблеммы, т.к. в РК86 это квадрат.

PrintCharFromC:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	PUSH	AF

	CALL	GetKeyboardStatus
	LD	HL,TOBACK
	PUSH	HL
	LD	HL,(POSX)
	EX	DE,HL
	LD	HL,(EK_ADR)
	LD	A,(ESC_FL)
	DEC	A
	JP	M,NO_ESC	; BUG Для VT-52 факт обработки ESC-последовательности не значит, что он игнорирует контрольные коды
	JP	Z,EscapeHandler	; если второй байт ('Y')
	DEC	A
	JP	Z,BYTE3		; если третий байт
	LD	A,C		; четвёртый байт
	SUB	20H
	LD	C,A
AFCDD:	DEC	C
	JP	M,EscapeHandlerEnd         ; СБРОС ESC_FL И ВЫХОД
	PUSH	BC
	CALL	CursorRight
	POP	BC
	JP	AFCDD

skip_TAB:
	INC	A		;CP	08H
	JP	Z,CursorLeft
	INC	A
	JP	NZ,skip_BEEP

; ──────────────────────────────────────────────
; Подача звукового сигнала
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, BC
; ОПИСАНИЕ:
; ──────────────────────────────────────────────

BEEP:	LD	BC,05F0H		; 20 bytes
SND_BC:	LD	A,B
BPLOO1:	EI
	DEC	A
	JP	NZ,BPLOO1
	LD	A,B
BPLOO2:	DI
	DEC	A
	JP	NZ,BPLOO2
	DEC	C
	JP	NZ,SND_BC
	RET

skip_BEEP:

	LD	(HL),C		; Видимый на экране символ

; ──────────────────────────────────────────────
; Перемещение курсора вправо
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	DE, HL, AF, BC
; ОПИСАНИЕ:
;	Курсор перемещается на одну позицию вправо. Если курсор был в конце
;	строки, то, в зависимости от флага переноса WRPFLG, он остается на
;	месте или перемещается на новую строку в первую позицию. Символы
;	на экране при перемещении курсора не стираются.
; ──────────────────────────────────────────────

CursorRight:
	LD	A, (WRPFLG)	;
	INC	A
	JP	Z, WRP
	LD	A,E		; POSX
	CP	MARGIN_LEFT+64	; последняя колонка ?
	RET	Z
WRP:	INC	HL		; следующий экранный адрес
	INC	E		; POSX ++
	LD	A,E		; POSX
	CP	MARGIN_LEFT+64	; последняя колонка ?
	RET	NZ
	LD	E,MARGIN_LEFT	; нач.позиция по X на новой строке
	LD	BC,-64
	ADD	HL,BC		; Вычесть 64 = экр.поз в начало строки
	RET


; ──────────────────────────────────────────────
; Перевод строки
; ВХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ИЗМЕНЯЕТ:
; 	DE, HL, BC, AF
; ОПИСАНИЕ:
;	Курсор перемещается на одну строку вниз в ту же позицию.
;	Если курсор был на нижней строке, то он там и остается,
;	а содержимое экрана сдвигается вверх на одну строку.
;	Информация, находившаяся на первой строке экрана, теряется.
;	Снизу добавляется пустая строка.
; ──────────────────────────────────────────────

LF:	LD	A,D
	CP	MARGIN_TOP+24	; мы на последней строке ?
	JP	NZ,CursorDown		; если не на последней строке

	PUSH	HL		; РОЛИК ЭКРАНА
	PUSH	DE
	LD	HL,SCBASE+78
	LD	DE,SCBASE
	LD	BC,25*78
MOVLOO:	LD	A,(HL)		; пересылка блока размером [BC]
	LD	(DE),A		; (HL) --> (DE)
	INC	HL
	INC	DE
	LOOP	MOVLOO
	POP	DE
	POP	HL
	RET

; ──────────────────────────────────────────────

AFEB3:	LD	L,20H			; 47 bytes
AFEB5:	LD	A,(PB)
	CPL
	OR	A
	JP	Z,AFEAF
	DEC	L
	JP	NZ,AFEB5
	LD	L,8
AFEC3:	DEC	L
	RLCA
	JP	NC,AFEC3
	LD	A,H
	LD	H,L
	LD	L,A
	CP	1
	JP	Z,AFEFA
	JP	C,AFEF3
	RLCA
	RLCA
	RLCA
	ADD	A,20H
	OR	H
	CP	5FH
	JP	NZ,AFF06
	LD	A,20H
	POP	HL
	RET

; ──────────────────────────────────────────────

AFE2A:	DEC	H			; в рег.A=код клав, в рег.H- COUNT
	JP	NZ,AFE21		; 39 bytes
	INC	A
	JP	Z,AFE22			; если код FF, то сброс флагов
	INC	A
	JP	Z,KEY_FE		; если код FE (RUSLAT)

	PUSH	BC			; КЛИК
	LD	BC,5003H
	CALL	SND_BC
	POP	BC

	LD	A,(APVFLG)
	LD	H,0E0H
	DEC	A
	LD	(APVFLG),A
	JP	Z,AFE4C
	LD	H,40H
AFE4C:	LD	A,0FFH
	JP	AFE22

; ──────────────────────────────────────────────

; После 15H вызовов GetKeyboardStatus при нажатой клавише выставляется флаг KBDFLG

GetKeyboardStatus:
	LD	A,(PC)		; 38 bytes
	RLA
	JP	NC,AFE0E	; если нажат RUS/LAT
	LD	A,(KBDFLG)
	OR	A
	RET	NZ		; если в SYMBUF уже есть символ
AFE0E:	PUSH	HL
	LD	HL,(LAST_K)
	CALL	ReadKeyCode
	CP	L
	LD	L,A
	JP	Z,AFE2A
AFE1A:	LD	A,1
	LD	(APVFLG),A
	LD	H,15H		; число опросов, чтобы зафиксировать код
AFE21:	XOR	A
AFE22:	LD	(LAST_K),HL
	POP	HL
	LD	(KBDFLG),A
	RET

; ──────────────────────────────────────────────

AFF1A:	LD	A,(RUSLAT)		; 33 bytes
	OR	A
	JP	Z,AFF2A
	LD	A,L
	CP	40H
	JP	M,AFF2A
	OR	20H
	LD	L,A
AFF2A:	LD	A,H
	AND	20H
	JP	NZ,AFF3F
	LD	A,L
	CP	40H
	JP	M,AFF3B
	LD	A,L
	XOR	20H
	POP	HL
	RET

; ──────────────────────────────────────────────

AFEFA:	LD	A,H			; 32 bytes
	LD	HL,TABK2
AFEFE:	ADD	A,L
	LD	L,A
	LD	A,(HL)
	CP	40H
	POP	HL
AFF04:	RET	C
	PUSH	HL
AFF06:	LD	L,A
	LD	A,(PC)
	LD	H,A
	AND	40H
	JP	NZ,AFF1A
	LD	A,L
	CP	40H
	JP	M,AFF3F
	AND	1FH
	POP	HL
	RET

; ──────────────────────────────────────────────

AFC34:	LD	HL,(TMPSTK)		; 18 bytes
	LD	SP,HL
	CALL	InitVideo
	LD	A,D
	OR	A
	JP	P,SyntaxError
	CALL	CHK_F4
	JP	AFB9C

; ──────────────────────────────────────────────
; Печать с новой строки знаение HL в 16-м формате, пробела и
; числа из ячейки памяти HL в 16-м формате и пробела
; ВХОД:
;	HL	- адрес байта числа для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

PrintCRAndHexWordAndSpaceAndHexByteMemAndSpace:
	CALL	PrintCRAndHexWordAndSpace			; 12 bytes

; ──────────────────────────────────────────────
; Печать числа из ячейки памяти HL в 16-м формате и пробела
; ВХОД:
;	HL	- адрес байта числа для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

PrintHexByteFromMemAndSpace:
	LD	A,(HL)

; ──────────────────────────────────────────────
; Печать числа из A в 16-м формате и пробела
; ВХОД:
;	A	- число для печати
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

PrintHexByteAndSpace:
	CALL	PrintHexByte

; ──────────────────────────────────────────────
; Печать пробела
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	A
; ──────────────────────────────────────────────

SPACE:	LD	A,20H
	JP	PrintCharFromA

; ──────────────────────────────────────────────
; Увеличивает HL и вызывает второй RET, если равен DE
; При нажатии Brk выходит с ошибкой в МОНИТОР
; ВХОД:
;	HL	- текущий адрес
;	DE	- целевой адрес
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

IncHLAndRetIfEqDEWithBrk:	CALL	CHK_F4			; 11 bytes

; ──────────────────────────────────────────────
; Увеличивает HL и вызывает второй RET, если равен DE
; ВХОД:
;	HL	- текущий адрес
;	DE	- целевой адрес
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

IncHLAndRetIfEqDE:
	CALL	Compare_HL_DE
	INC	HL
	RET	NZ
	DEC	HL
POPAF:	POP	AF
	RET

; ──────────────────────────────────────────────
;BDOS function 6 (C_RAWIO) - Direct console I/O
;Supported by: CP/M 1.4 and later, with variations
;Entered with C=6, E=code. Returned values (in A) vary.
;
;E=0FFh
;Return a character without echoing if one is waiting;
; zero if none is available. In MP/M 1, this works like
; E=0FDh below and waits for a character.
;Values of E not supported on a particular system will
; output the character. Under CP/M 2 and lower, direct 
;console functions may interact undesirably with non-direct
; ones, since certain buffers may be bypassed. Do not mix them.
; ──────────────────────────────────────────────

FUNC06:	INC	E		; Test for 0FFH
	JP	NZ,PrintCharFromC
	CALL	GetKeyboardStatus
	RET	Z

; ──────────────────────────────────────────────
; Ввод символа с ожиданием. 
; ВХОД:
;	Нет
; ВЫХОД:
;	A - введенный символ
; ИЗМЕНЯЕТ:
;	AF		 TODO: проверить, что изменяет GetKeyboardStatus
; ──────────────────────────────────────────────

InputSymbol:
	CALL	GetKeyboardStatus
	OR	A
	JP	Z,InputSymbol
	XOR	A
	LD	(KBDFLG),A
	LD	A,(LAST_K)
	RET


; ──────────────────────────────────────────────

TABK1:	DB	0CH,1FH,1BH,0,1,2,3,4,5	  ; 9 bytes

; ──────────────────────────────────────────────

TOBACK: LD	(EK_ADR),HL		; 23 bytes
	EX	DE,HL
	LD	(POSX),HL
	LD	A,80H
	LD	(VG_75+1),A
	LD	A,L
	LD	(VG_75),A
	LD	A,H
	LD	(VG_75),A
	JP	POPREGA

; ──────────────────────────────────────────────

LD_BLK:	CALL	TapeReadByteNoSync			; 10 bytes
	LD	(HL),A
	CALL	IncHLAndRetIfEqDE
	JP	LD_BLK

; ──────────────────────────────────────────────
; Обработчик ESC-последовательности
; ВХОД:
;	C=ESC-код
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B, DE, HL
; ОПИСАНИЕ:
;	Поддерживаемые ESC-последовательности:
;		ESC A	- Cursor Up
;		ESC B	- Cursor Down
;		ESC C	- Cursor Right
;		ESC D	- Cursor Left
;		ESC E	- Clear screen (GEMDOS/TOS extension)
;		ESC H	- Cursor Home
;		ESC I	- Reverse Line Feed
;		ESC J	- Erase to End Of Screen
;		ESC K	- Erase to End Of Line
;		ESC L	- Insert line (not VT52)
;		ESC M	- Delete line (not VT52)
;		ESC Y	- Direct Cursor Addressing
;		ESC e	- Enable cursor (GEMDOS/TOS extension)
;		ESC f	- Disable cursor(GEMDOS/TOS extension)
;		ESC j	- Save cursor (GEMDOS/TOS extension)
;		ESC k	- Restore cursor(GEMDOS/TOS extension)
;		ESC v	- Wrap off (GEMDOS/TOS extension)
;		ESC w	- Wrap on (GEMDOS/TOS extension)
;	Здесь используется немного нестандартная схема выбора обработчика.
;	Обработчики не вызываются для каждого символа отдельно, а встроены
;	непосредственно в логику ветвления. Для этого символ в A
;	уменьшаетя на величину 'w' (максимальный управляющий символ).
;	После чего происходит для каждого символа увеличение на дельту.
;	По JP NZ осуществляется обход кода обработчика, если он нам не нужен.
;	Сам обработчик должен обеспечить только, чтобы регистр A на выходе
;	был меньше, чем 0A0H. Тогда не будет фальш-сработок. При вызове обработчика
;	будет осущетсвляться перебор и обход кода всех обработчисков и в конце будет
;	возврат через EscapeHandlerEnd. Такой метод позволит сэкономить на команде
;	RET для каждого обработчика. Если использовать таблицы, то каждый вызов
;	потребует 3 байта в таблице+RET+код обработки таблицы. Здесь же каждый
;	обработчик потребует 4 байта. Т.е. экономия на размер обработчика таблицы
; ──────────────────────────────────────────────

EscapeHandler:
	LD	A,C
	PUSH	HL
	LD	HL, EscapeHandlerEnd
	EX	(SP), HL
	SUB	'w'		;CP	'w'
	JP	NZ, skip_ESC_w

; ──────────────────────────────────────────────
; Включить автоперенос строки
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE, AF, BC
; ОПИСАНИЕ:
; ──────────────────────────────────────────────
WrapOn:	XOR	A
	LD	(WRPFLG), A

skip_ESC_w:
	INC	A		;CP	'v'
	JP	NZ, skip_ESC_v

; ──────────────────────────────────────────────
; Выключить автоперенос строки
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE, AF, BC
; ОПИСАНИЕ:
; ──────────────────────────────────────────────
WrapOff:
	LD	A, 0FFh
	LD	(WRPFLG), A

skip_ESC_v:
	ADD	A, 'v'-'k'	;CP	'k'
	JP	NZ, skip_ESC_k

; ──────────────────────────────────────────────
; Восстановить сохраненные координаты курсора
; ВХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ВЫХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE
; ──────────────────────────────────────────────
CursorRestore:
	LD	HL, (XYSTOR)
	EX	DE, HL
	LD	HL, (SASTOR)
	EX	DE, HL

skip_ESC_k:
	INC	A		;CP	'j'
	JP	NZ, skip_ESC_j

; ──────────────────────────────────────────────
; Сохранить текущие координаты курсора
; ВХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ВЫХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────
CursorSave:
	LD	(SASTOR), HL
	EX	DE, HL
	LD	(XYSTOR), HL
	EX	DE, HL

skip_ESC_j:
	ADD	A, 'j'-'f'	;CP	'f'
	JP	NZ, skip_ESC_f

; ──────────────────────────────────────────────
; Скрыть курсор
; ВХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ВЫХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────
CursorDisable:
	LD	A, 0A9H
	LD	(CURST), A

skip_ESC_f:
	INC	A		;CP	'e'
	JP	NZ, skip_ESC_e

CursorEnable:
; ──────────────────────────────────────────────
; Отобразить курсор
; ВХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ВЫХОД:
;	E - X координата курсора
;	D - Y координата курсора
;	HL - экранный адрес
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────
	LD	A, 099H
	LD	(CURST), A

skip_ESC_e:
	ADD	A, 'e'-'Y'	;CP	'Y'
	JP	NZ, skip_ESC_Y
	;esc_Y

	CALL	CursorHome
	INC	A		;LD	A,2; ПРИНЯТО 2 БАЙТА ESC,'Y'

; ──────────────────────────────────────────────
; Запуск обработчика ESC-символа
; ВХОД:
;	A=0
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF, B
; ──────────────────────────────────────────────

EscapeHandlerStart:
	INC	A		; LD A, 1 - для EscapeHandlerStart и LD A, 2 - для EscapeHAndler
	DB	06H		; LD B, ... функционально JP SETESC

; ──────────────────────────────────────────────
; Завершение обработки ESC-последовательности
; ВХОД:
;	Нет
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ──────────────────────────────────────────────

EscapeHandlerEnd:
	XOR	A		; LD A, 0

; ──────────────────────────────────────────────
; Установить режим обработки ESC-последовательности
; ВХОД:
;	A=режим
;		0 - завершить обработку последовательности
;		1 - обработка кода ESC-последовательности
;		2 - обработка первого символа Y-последовательности
;		3 - обработка второго символа Y-последовательности
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

SETESC:	LD	(ESC_FL),A
	RET

skip_ESC_Y:
	ADD	A, 'Y'-'M'	;CP	'M'
	JP	NZ, skip_ESC_M

; ──────────────────────────────────────────────
; Удалить строку
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE, AF, BC
; ОПИСАНИЕ:
; ──────────────────────────────────────────────
DeleteLine:

skip_ESC_M:
	INC	A		;CP	'L'
	JP	NZ, skip_ESC_L

; ──────────────────────────────────────────────
; Вставить строку
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE, AF, BC
; ОПИСАНИЕ:
; ──────────────────────────────────────────────
InsertLine:

skip_ESC_L:
	INC	A		;CP	'K'
	JP	NZ, skip_ESC_K

; ──────────────────────────────────────────────
; Очистка от курсора до конца строки
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	AF, BC
; ОПИСАНИЕ:
; ──────────────────────────────────────────────
ClearEOL:
	PUSH	HL
	PUSH	DE
KLOOP:	CALL	SPACE
	LD	A, E
	CP	MARGIN_LEFT+63		; последняя колонка
	JP	NZ, KLOOP
	POP	DE
	POP	HL

skip_ESC_K:
	INC	A		;CP	'J'
	JP	NZ, skip_ESC_J

; ──────────────────────────────────────────────
; Очистка до конца экрана
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	AF, BC
; ОПИСАНИЕ:
; ──────────────────────────────────────────────
ClearEOS:
	PUSH	HL
	PUSH	DE
	LD	D, 0
	CALL	SUBHLDE
	CALL	CLSLOO
	POP	DE
	POP	HL

skip_ESC_J:
	INC	A		;CP	'I'
	JP	NZ, skip_ESC_I

; ──────────────────────────────────────────────
; Обратный перевод строки
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE, AF, BC
; ОПИСАНИЕ:
;	Курсор перемещается вверх на одну строку в ту же позицию. Если
;	курсор был на самой верхней строке, то он не перемещается, но
;	вся информация на экране перемещается вниз на одну строку.
;	Информация с нижней строки теряется, а сверху добавляется новая
;	пустая строка.
; ──────────────────────────────────────────────

RLF:	LD	A,D
	CP	3		; это первая строка ?
	JP	NZ,CursorUp	; если не на первой строке

	PUSH	HL		; РОЛИК ЭКРАНА
	PUSH	DE
	LD	HL,SCBASE+25*78
	LD	DE,SCBASE+78+25*78
	LD	BC,25*78
MOVLO:	LD	A,(HL)		; пересылка блока размером [BC]
	LD	(DE),A		; (HL) --> (DE)
	DEC	HL
	DEC	DE
	LOOP	MOVLO
	POP	DE
	POP	HL

skip_ESC_I:
	INC	A		;CP	'H'
	JP	Z, CursorHome
	ADD	A, 'H'-'E'	;CP	'E'
	JP	NZ, skip_ESC_E

; ──────────────────────────────────────────────

ClearScreen:
	LD	HL,SA		; 17 bytes
CLSLOO:	XOR	A
	LD	(HL),A
	INC	HL
	OR	H
	JP	P,CLSLOO
CursorHome:
	LD	DE, MARGIN_TOP << 8 +MARGIN_LEFT
	LD	HL, SCBASE

skip_ESC_E:
	INC	A		;CP	'D'
	JP	NZ, skip_ESC_D

; ──────────────────────────────────────────────
; Перемещение курсора влево
; ВХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ИЗМЕНЯЕТ:
;	AF, HL, DE
; ОПИСАНИЕ:
;	Курсор перемещается на одну позицию влево. Если курсор в начале строки, то
;	он не перемещается. Символ на экране не стирается.
; ──────────────────────────────────────────────

CursorLeft:
	LD	A,E		; 7 bytes
	CP	MARGIN_LEFT
	JP	Z, skip_ESC_D
	DEC	HL
	DEC	E

skip_ESC_D:
	INC	A		;CP	'C'
	JP	Z, CursorRight

	INC	A		;CP	'B'
	JP	NZ, skip_ESC_B

; ──────────────────────────────────────────────
; Перемещение курсора вниз
; ВХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL=экранный адрес
; ИЗМЕНЯЕТ:
;
; ОПИСАНИЕ:
; 	Курсор перемещается вниз на одну строку в ту же
;	позицию. Если курсор находится внизу экрана, то
;	курсор остается на той же позиции и скролинг
;	не осуществляется.
; ──────────────────────────────────────────────

CursorDown:
	LD	A,D
	CP	MARGIN_TOP+24	; последняя строка ?
	RET	Z
	LD	BC,78
	INC	D
	ADD	HL,BC		; Прибавить 78

skip_ESC_B:
	INC	A		; CP	'A'
	RET	NZ

; ──────────────────────────────────────────────
; Перемещение курсора вверх
; ВХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ВЫХОД:
;	E=POSX, D=POSY
;	HL= экранный адрес
; ИЗМЕНЯЕТ:
;	HL, DE, BC, AF
; ОПИСАНИЕ:
;	Курсор перемещается вверх на одну строку в ту же позицию. Если курсор
;	находится в самом верху, то он не перемещается.
; ──────────────────────────────────────────────

CursorUp:
	LD	A,D		; 10 bytes
	CP	MARGIN_TOP	; это первая строка ?
	RET	Z
	LD	BC,-78
	DEC	D
	ADD	HL,BC		; Вычесть 78
	RET

; ──────────────────────────────────────────────
; Вычитает из HL DE
; ВХОД:
;	HL	- уменьшаемое
;	DE	- вычитаемое
; ВЫХОД:
;	HL	- результат
; ИЗМЕНЯЕТ:
;	HL, AF
; ОПИСАНИЕ:
;	Вычитает DE из HL
; ──────────────────────────────────────────────

SUBHLDE:
	if	0
	XOR	A
	SUB	E
	LD	E,A
	SBC	A,A
	SUB	D
	LD	D,A
	ADD	HL, DE
	RET
	endif
	LD	A, L
	SUB	E
	LD	L, A
	LD	A, H
	SBC	A, D
	LD	H, A
	RET

	IF	0
; ──────────────────────────────────────────────
; Блок эмуляции точек входа BIOS и BDOS
; ──────────────────────────────────────────────

BIOSENTRY:
	JP	BDOS		; CBOOT Холодный старт
	JP	WarmBoot	; WBOOT Теплый старт
	JP	GetKeyboardStatus		; CONST Статус консоли
	JP	InputSymbol	; CONIN Консольный ввод
	JP	PrintCharFromC	; CONOUT Консольный вывод
BIOSENTRYEND:


; ──────────────────────────────────────────────
; Блок эмуляции точек входа BDOS
; ──────────────────────────────────────────────

BDOS:	LD	HL, 0000H	; Сохраняем стек
	ADD	HL, SP
	LD	(TMPSTK), HL
	LD	SP, STACK
	DEC	C
	JP	M, ColdBoot	; Функция 0 P_TERMCPM
	LD	HL, BDOSRET
	PUSH	HL
	LD	A, C
	LD	C, E
	JP	Z, FUNC01	; Функция 1 C_READ
	DEC	A
	JP	Z, PrintCharFromC	; Функция 2 C_WRITE
	SUB	4
	JP	Z, FUNC06	; Функция 6 C_RAWIO
	SUB	3
	JP	Z, MSGCPM	; Функция 9 C_WRITESTR
	DEC	A
	JP	Z, GETLIN2	; Функция 10 C_READSTR
	DEC	A
	JP	Z, GetKeyboardStatus	; Функция 11 C_STAT
	DEC	A
	JP	NZ, ColdBoot	; Функции 13 и выше
	LD	A, 20H		; Функция 12
	LD	B, 00H
	RET

FUNC01:	CALL	InputSymbol
	JP	PrintCharFromA

;
;BDOS function 10 (C_READSTR) - Buffered console input
;Supported by: All versions, with variations
;Entered with C=0Ah, DE=address or zero.
;
;This function reads characters from the keyboard into a memory buffer
; until RETURN is pressed. The Delete key is handled correctly. In later
; versions, more features can be used at this point; ZPM3 includes a
; full line editor with recall of previous lines typed.
;
;On entry, DE is the address of a buffer. If DE=0, the DMA address
; is used (CP/M 3 and later)
; and the buffer already contains data:
;
;DE=address:                 DE=0 :
;buffer: DEFB    size        buffer: DEFB    size
        ;DEFB    ?                   DEFB    len
        ;DEFB    bytes               DEFB    bytes
;;The value at buffer+0 is the amount of bytes available in the
; buffer. Once the limit has been reached, no more can be added,
; although the line editor can still be used.
;If DE=0 (in 16-bit versions, DX=0FFFFh) the next byte contains 
;the number of bytes already in the buffer; otherwise this is 
;ignored. On return from the function, it contains the number 
;of bytes present in the buffer.
;
;The bytes typed then follow. There is no end marker.
;

	if 0
	EX	DE, HL
	LD	C, (HL)
	LD	B, 00H
	INC	HL
L008CH:	CALL	0F803H
	CP	7FH
	JP	Z, L00B6H
	CALL	PrintCharFromA
	CP	0DH
	JP	Z, L00B2H
	CP	03H
	JP	Z, 0F800H
	INC	HL
	LD	(HL), A
	INC	B
	LD	A, C
	CP	B
	JP	NZ, L008CH
	LD	B, C

L00B2H:	INC	DE
	EX	DE, HL
	LD	(HL), B
	RET

L00B6H:	LD	A, B
	OR	A
	JP	Z, L008CH
	DEC	B
	DEC	HL
	;PUSH	HL
	CALL	RST_18
	DB	8, ' ', 8+80h		; см. TZABOJ
	;POP	HL
	JP	L008CH
	endif

BDOSRET:
	LD	HL, (TMPSTK)             ; Точка возврата из функции BDOS
	LD	SP, HL
	LD	L, A
	LD	H, B
	RET

; ──────────────────────────────────────────────
; Инициализация симулятора CP/M
; ВХОД:
;	HL=100H
; ВЫХОД:
;	Нет
; ИЗМЕНЯЕТ:
;	AF
; ОПИСАНИЕ:
; Перемещает эмулятор BIOS и BDOS в верхние адреса памяти
; Корректирует точку входа в BIOS и BDOS
; ──────────────────────────────────────────────

INIT:
	PUSH	HL
	PUSH	DE
	LD	A, 0C3H
	LD	(0), A
	LD	(5), A
	LD	HL, RAMTOP-100H+3
	LD	(0001H), HL
	LD	HL, RAMTOP-100H
	LD	(0006H), HL
	EX	DE, HL
	LD	HL, BIOSENTRY
	LD	BC, BIOSENTRYEND-BIOSENTRY
	JP	MOVLOO

	ENDIF

; ──────────────────────────────────────────────
; Запись блока с HL по DE на магнитофон
; ВХОД:
;	HL	- начало блока
;	DE	- конец блока
; ВЫХОД:
;	HL	- конец блока
; ИЗМЕНЯЕТ:
;	AF, C, HL
; ──────────────────────────────────────────────

TapeWriteFromHLtoDE:
	LD	C,(HL)			; 10 bytes
	CALL	TapeWriteByte
	CALL	IncHLAndRetIfEqDE
	JP	TapeWriteFromHLtoDE

; ──────────────────────────────────────────────
; Ввод символа без ожидания с проверкой нажатия Ctrl-C. 
; При нажатии Ctrl-C выход в МОНИТОР с переинцициализацией ВГ.
; ВХОД:
;	Нет
; ВЫХОД:
;	A=0FFH - не нажата
;	A=0FEH - РУС/ЛАТ
;	A - код клавиши
; ИЗМЕНЯЕТ:
;	AF		 TODO: проверить, что изменяет ReadKeyCode и InitVideo
; ──────────────────────────────────────────────

CHK_F4:	CALL	ReadKeyCode			; 12 bytes
	CP	3
	RET	NZ
	CALL	InitVideo
	JP	SyntaxError

; ──────────────────────────────────────────────

ReadKeyCode:
	LD	A,(PC)		; 30 bytes
	RLA
	LD	A,0FEH
	RET	NC
AFE7D:
	XOR	A
	LD	(PA),A
	LD	A,(RUSLAT)
	AND	00000001B
	OR	00000110B	; зажигаем/гасим светодиод
	LD	(PU),A
	LD	A,(PB)
	INC	A
	JP	NZ,AFE97
	DEC	A
	RET

; ──────────────────────────────────────────────

ProcessBackspace:
	LD	A,E			; 15 bytes
	CP	L			; начало буфера ввода ?
	JP	Z,GotoCmdLineBegin
	CALL	RST_18
	DB	8,' ',8+128
	DEC	HL
	JP	InputNextSymbol

READARAM	; +36
WRITEARAM	; +39
SetCursorPos		; +3C
	RET

; ──────────────────────────────────────────────
; Возвращает символ в текущих координатах видео ОЗУ
; ВХОД:
;	Нет
; ВЫХОД:
;	A	- символ в текущих координатах
; ИЗМЕНЯЕТ:
;	A
; ──────────────────────────────────────────────

ReadVideoRAM:
	PUSH	HL			; 7 bytes
	LD	HL,(EK_ADR)
	LD	A,(HL)
	POP	HL
	RET

; ──────────────────────────────────────────────
; Возвращает верхнею границу свободного ОЗУ
; ВХОД:
;	Нет
; ВЫХОД:
;	HL	- адрес последней доступной ячейки ОЗУ
; ИЗМЕНЯЕТ:
;	HL
; ──────────────────────────────────────────────

GetFreeMemAddr:
	LD	HL,(RAMTOP)	; +30

; ──────────────────────────────────────────────
; Устанавливает верхнею границу свободного ОЗУ
; ВХОД:
;	HL	- адрес последней доступной ячейки ОЗУ
; ВЫХОД:
;	HL	- адрес последней доступной ячейки ОЗУ
; ИЗМЕНЯЕТ:
;	Нет
; ──────────────────────────────────────────────

SetFreeMemAddr:
	LD	(RAMTOP),HL	; +33
	RET

	END

